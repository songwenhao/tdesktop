<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Range-v3: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Range-v3
   </div>
   <div id="projectbrief">Range algorithms, views, and actions for the Standard Library</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group-algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Algorithms</div></div>
</div><!--header-->
<div class="contents">

<p>Iterator- and range-based algorithms, like the standard algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplParams" colspan="2"><a id="ga4ec55cd1aee7604d0c5a335fb3d8641b" name="ga4ec55cd1aee7604d0c5a335fb3d8641b"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::binary_transform_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:ga4ec55cd1aee7604d0c5a335fb3d8641b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplParams" colspan="2"><a id="ga58e197a7893ec8659fb7e2513130f7cf" name="ga58e197a7893ec8659fb7e2513130f7cf"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga58e197a7893ec8659fb7e2513130f7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplParams" colspan="2"><a id="ga5a179c5b7b8620b7fd95dc315cab0a39" name="ga5a179c5b7b8620b7fd95dc315cab0a39"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga5a179c5b7b8620b7fd95dc315cab0a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplParams" colspan="2"><a id="gae2ac60776de9431e79a65c4897bd2e3d" name="gae2ac60776de9431e79a65c4897bd2e3d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_n_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gae2ac60776de9431e79a65c4897bd2e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplParams" colspan="2"><a id="gab309c6678ed7ad0eea22415f3d66514a" name="gab309c6678ed7ad0eea22415f3d66514a"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gab309c6678ed7ad0eea22415f3d66514a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gab309c6678ed7ad0eea22415f3d66514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplParams" colspan="2"><a id="ga84025d197692778e238c2143ee2dcdee" name="ga84025d197692778e238c2143ee2dcdee"></a>
template&lt;typename I , typename F &gt; </td></tr>
<tr class="memitem:ga84025d197692778e238c2143ee2dcdee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each_result</b> = detail::in_fun_result&lt; I, F &gt;</td></tr>
<tr class="separator:ga84025d197692778e238c2143ee2dcdee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplParams" colspan="2"><a id="ga0cd85c482465e0fef02aec6733ec5e8a" name="ga0cd85c482465e0fef02aec6733ec5e8a"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_n_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga0cd85c482465e0fef02aec6733ec5e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplParams" colspan="2"><a id="ga4b78921a0e76ce435f8c180041296192" name="ga4b78921a0e76ce435f8c180041296192"></a>
template&lt;typename O , typename F &gt; </td></tr>
<tr class="memitem:ga4b78921a0e76ce435f8c180041296192"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_result</b> = detail::out_fun_result&lt; O, F &gt;</td></tr>
<tr class="separator:ga4b78921a0e76ce435f8c180041296192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplParams" colspan="2"><a id="ga4fb3de5f6f61105bed9816cbbe1c20e4" name="ga4fb3de5f6f61105bed9816cbbe1c20e4"></a>
template&lt;typename I0 , typename I1 , typename O &gt; </td></tr>
<tr class="memitem:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::merge_result</b> = detail::in1_in2_out_result&lt; I0, I1, O &gt;</td></tr>
<tr class="separator:ga4fb3de5f6f61105bed9816cbbe1c20e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplParams" colspan="2"><a id="ga2551631b044f18c25ebf252d89ab62d1" name="ga2551631b044f18c25ebf252d89ab62d1"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:ga2551631b044f18c25ebf252d89ab62d1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_element_result</b> = detail::min_max_result&lt; I, I &gt;</td></tr>
<tr class="separator:ga2551631b044f18c25ebf252d89ab62d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplParams" colspan="2"><a id="ga33d3732bfda9763bacb492f678c49ac2" name="ga33d3732bfda9763bacb492f678c49ac2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga33d3732bfda9763bacb492f678c49ac2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_result</b> = detail::min_max_result&lt; T, T &gt;</td></tr>
<tr class="separator:ga33d3732bfda9763bacb492f678c49ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplParams" colspan="2"><a id="ga228c0cdeb71847092b416b855e17c017" name="ga228c0cdeb71847092b416b855e17c017"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga228c0cdeb71847092b416b855e17c017"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga228c0cdeb71847092b416b855e17c017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplParams" colspan="2"><a id="gaf3ddbe128fcdd14998784890ae88172c" name="gaf3ddbe128fcdd14998784890ae88172c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf3ddbe128fcdd14998784890ae88172c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_backward_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf3ddbe128fcdd14998784890ae88172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplParams" colspan="2"><a id="gaa9e56e40c245536a73cd3c4479aa71f0" name="gaa9e56e40c245536a73cd3c4479aa71f0"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaa9e56e40c245536a73cd3c4479aa71f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplParams" colspan="2"><a id="ga196586ea2693c3b679d7c75c8c8c4eb2" name="ga196586ea2693c3b679d7c75c8c8c4eb2"></a>
template&lt;typename I , typename O0 , typename O1 &gt; </td></tr>
<tr class="memitem:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_copy_result</b> = detail::in_out1_out2_result&lt; I, O0, O1 &gt;</td></tr>
<tr class="separator:ga196586ea2693c3b679d7c75c8c8c4eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplParams" colspan="2"><a id="ga81824d68277efdaa55addad2b5a1ab09" name="ga81824d68277efdaa55addad2b5a1ab09"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga81824d68277efdaa55addad2b5a1ab09"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga81824d68277efdaa55addad2b5a1ab09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplParams" colspan="2"><a id="gacbea707ae03721b200a22fe6918920d8" name="gacbea707ae03721b200a22fe6918920d8"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gacbea707ae03721b200a22fe6918920d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gacbea707ae03721b200a22fe6918920d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplParams" colspan="2"><a id="gaf4f4af78a9add9145c784b58d209e16e" name="gaf4f4af78a9add9145c784b58d209e16e"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf4f4af78a9add9145c784b58d209e16e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_if_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf4f4af78a9add9145c784b58d209e16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplParams" colspan="2"><a id="gadf2b15655eb4ca83a6615695d37dc191" name="gadf2b15655eb4ca83a6615695d37dc191"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gadf2b15655eb4ca83a6615695d37dc191"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gadf2b15655eb4ca83a6615695d37dc191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplParams" colspan="2"><a id="ga7bff287e5ec676e01a086ac147d4b618" name="ga7bff287e5ec676e01a086ac147d4b618"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga7bff287e5ec676e01a086ac147d4b618"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga7bff287e5ec676e01a086ac147d4b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplParams" colspan="2"><a id="gaebb905dac3fee120cf77b39e821c277c" name="gaebb905dac3fee120cf77b39e821c277c"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaebb905dac3fee120cf77b39e821c277c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaebb905dac3fee120cf77b39e821c277c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplParams" colspan="2"><a id="ga8571d401e506014ea1a86618ca01545f" name="ga8571d401e506014ea1a86618ca01545f"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga8571d401e506014ea1a86618ca01545f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga8571d401e506014ea1a86618ca01545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplParams" colspan="2"><a id="ga46e34ec570ccc79f695689635145bed4" name="ga46e34ec570ccc79f695689635145bed4"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:ga46e34ec570ccc79f695689635145bed4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_difference_result</b> = detail::in1_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:ga46e34ec570ccc79f695689635145bed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplParams" colspan="2"><a id="gaa40276d355563038380b94ca8c500cd2" name="gaa40276d355563038380b94ca8c500cd2"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa40276d355563038380b94ca8c500cd2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_symmetric_difference_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa40276d355563038380b94ca8c500cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplParams" colspan="2"><a id="gaa28c664ec5818d4c1e4458486d109519" name="gaa28c664ec5818d4c1e4458486d109519"></a>
template&lt;typename I1 , typename I2 , typename O &gt; </td></tr>
<tr class="memitem:gaa28c664ec5818d4c1e4458486d109519"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_union_result</b> = detail::in1_in2_out_result&lt; I1, I2, O &gt;</td></tr>
<tr class="separator:gaa28c664ec5818d4c1e4458486d109519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplParams" colspan="2"><a id="ga3a91c5c1590ec2c0cf1a56ea2e363dea" name="ga3a91c5c1590ec2c0cf1a56ea2e363dea"></a>
template&lt;typename I1 , typename I2 &gt; </td></tr>
<tr class="memitem:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges_result</b> = detail::in1_in2_result&lt; I1, I2 &gt;</td></tr>
<tr class="separator:ga3a91c5c1590ec2c0cf1a56ea2e363dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplParams" colspan="2"><a id="gaef72d2db7ea1c57f60101e18336e4037" name="gaef72d2db7ea1c57f60101e18336e4037"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaef72d2db7ea1c57f60101e18336e4037"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unary_transform_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaef72d2db7ea1c57f60101e18336e4037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplParams" colspan="2"><a id="gaf7ea4487e401b787c778cbc28e43913d" name="gaf7ea4487e401b787c778cbc28e43913d"></a>
template&lt;typename I , typename O &gt; </td></tr>
<tr class="memitem:gaf7ea4487e401b787c778cbc28e43913d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unique_copy_result</b> = detail::in_out_result&lt; I, O &gt;</td></tr>
<tr class="separator:gaf7ea4487e401b787c778cbc28e43913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacf0b2a91574c38d011d8b768f1ca8a01"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gacf0b2a91574c38d011d8b768f1ca8a01"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacf0b2a91574c38d011d8b768f1ca8a01">ranges::adjacent_find</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gacf0b2a91574c38d011d8b768f1ca8a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>adjacent_find</code>  <a href="group__group-algorithms.html#gacf0b2a91574c38d011d8b768f1ca8a01">More...</a><br /></td></tr>
<tr class="separator:gacf0b2a91574c38d011d8b768f1ca8a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c39b603bb920e33e9bfbc1e0b33bdb"><td class="memTemplParams" colspan="2"><a id="gae9c39b603bb920e33e9bfbc1e0b33bdb" name="gae9c39b603bb920e33e9bfbc1e0b33bdb"></a>
template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gae9c39b603bb920e33e9bfbc1e0b33bdb"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::adjacent_find</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gae9c39b603bb920e33e9bfbc1e0b33bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gae9c39b603bb920e33e9bfbc1e0b33bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7060ffb2fa3f5a8d659c0dac8d92d84"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename Pred , typename Proj  = identity&gt; <br />
requires permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;Pred, projected&lt;I, Proj&gt;&gt;</td></tr>
<tr class="memitem:gab7060ffb2fa3f5a8d659c0dac8d92d84"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gab7060ffb2fa3f5a8d659c0dac8d92d84">ranges::adjacent_remove_if</a> (I first, S last, Pred pred={}, Proj proj={})</td></tr>
<tr class="memdesc:gab7060ffb2fa3f5a8d659c0dac8d92d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">function <code>adjacent_remove_if</code>  <a href="group__group-algorithms.html#gab7060ffb2fa3f5a8d659c0dac8d92d84">More...</a><br /></td></tr>
<tr class="separator:gab7060ffb2fa3f5a8d659c0dac8d92d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3795e0ef907776e7e6d9cb3faddab960"><td class="memTemplParams" colspan="2"><a id="ga3795e0ef907776e7e6d9cb3faddab960" name="ga3795e0ef907776e7e6d9cb3faddab960"></a>
template&lt;typename Rng , typename Pred , typename Proj  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;Pred, projected&lt;iterator_t&lt;Rng&gt;, Proj&gt;&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt;</td></tr>
<tr class="memitem:ga3795e0ef907776e7e6d9cb3faddab960"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::adjacent_remove_if</b> (Rng &amp;&amp;rng, Pred pred, Proj proj={})</td></tr>
<tr class="memdesc:ga3795e0ef907776e7e6d9cb3faddab960"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3795e0ef907776e7e6d9cb3faddab960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbbe7ae1e71bae67c5f654de7aa3e1c"><td class="memTemplParams" colspan="2"><a id="ga3fbbe7ae1e71bae67c5f654de7aa3e1c" name="ga3fbbe7ae1e71bae67c5f654de7aa3e1c"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga3fbbe7ae1e71bae67c5f654de7aa3e1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::all_of</b> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga3fbbe7ae1e71bae67c5f654de7aa3e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>all_of</code> <br /></td></tr>
<tr class="separator:ga3fbbe7ae1e71bae67c5f654de7aa3e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab80e37eadac4b3c68d4dc32b9baee929"><td class="memTemplParams" colspan="2"><a id="gab80e37eadac4b3c68d4dc32b9baee929" name="gab80e37eadac4b3c68d4dc32b9baee929"></a>
template&lt;typename Rng , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gab80e37eadac4b3c68d4dc32b9baee929"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::all_of</b> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gab80e37eadac4b3c68d4dc32b9baee929"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab80e37eadac4b3c68d4dc32b9baee929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd98a14d870997c0331a00d906cd4bbe"><td class="memTemplParams" colspan="2"><a id="gacd98a14d870997c0331a00d906cd4bbe" name="gacd98a14d870997c0331a00d906cd4bbe"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gacd98a14d870997c0331a00d906cd4bbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::any_of</b> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gacd98a14d870997c0331a00d906cd4bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>any_of</code> <br /></td></tr>
<tr class="separator:gacd98a14d870997c0331a00d906cd4bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa55a93ed4b80a5f2b31b5ddca3d8cb1"><td class="memTemplParams" colspan="2"><a id="gafa55a93ed4b80a5f2b31b5ddca3d8cb1" name="gafa55a93ed4b80a5f2b31b5ddca3d8cb1"></a>
template&lt;typename Rng , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gafa55a93ed4b80a5f2b31b5ddca3d8cb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::any_of</b> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gafa55a93ed4b80a5f2b31b5ddca3d8cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gafa55a93ed4b80a5f2b31b5ddca3d8cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b75f3fb053f2570b46a82a2ddbe9ca9"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga5b75f3fb053f2570b46a82a2ddbe9ca9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga5b75f3fb053f2570b46a82a2ddbe9ca9">ranges::binary_search</a> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga5b75f3fb053f2570b46a82a2ddbe9ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>binary_search</code>  <a href="group__group-algorithms.html#ga5b75f3fb053f2570b46a82a2ddbe9ca9">More...</a><br /></td></tr>
<tr class="separator:ga5b75f3fb053f2570b46a82a2ddbe9ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a262b0ef79bfc3c0d70c1748f6ae7f1"><td class="memTemplParams" colspan="2"><a id="ga1a262b0ef79bfc3c0d70c1748f6ae7f1" name="ga1a262b0ef79bfc3c0d70c1748f6ae7f1"></a>
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga1a262b0ef79bfc3c0d70c1748f6ae7f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::binary_search</b> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga1a262b0ef79bfc3c0d70c1748f6ae7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga1a262b0ef79bfc3c0d70c1748f6ae7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac71975b2fb33a148685ca0d614c00356"><td class="memTemplParams" colspan="2"><a id="gac71975b2fb33a148685ca0d614c00356" name="gac71975b2fb33a148685ca0d614c00356"></a>
template&lt;typename I , typename S , typename T , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, const T *&gt;</td></tr>
<tr class="memitem:gac71975b2fb33a148685ca0d614c00356"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::contains</b> (I first, S last, const T &amp;val, P proj={})</td></tr>
<tr class="memdesc:gac71975b2fb33a148685ca0d614c00356"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>contains</code> <br /></td></tr>
<tr class="separator:gac71975b2fb33a148685ca0d614c00356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33d7bcb2b6449435a5a711b9d8003c13"><td class="memTemplParams" colspan="2"><a id="ga33d7bcb2b6449435a5a711b9d8003c13" name="ga33d7bcb2b6449435a5a711b9d8003c13"></a>
template&lt;typename Rng , typename T , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, const T *&gt;</td></tr>
<tr class="memitem:ga33d7bcb2b6449435a5a711b9d8003c13"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::contains</b> (Rng &amp;&amp;rng, const T &amp;val, P proj={})</td></tr>
<tr class="memdesc:ga33d7bcb2b6449435a5a711b9d8003c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga33d7bcb2b6449435a5a711b9d8003c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf50f6b198924b15f2438ee3b17592a1a"><td class="memTemplParams" colspan="2"><a id="gaf50f6b198924b15f2438ee3b17592a1a" name="gaf50f6b198924b15f2438ee3b17592a1a"></a>
template&lt;typename I , typename S , typename O &gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:gaf50f6b198924b15f2438ee3b17592a1a"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy</b> (I first, S last, O out)</td></tr>
<tr class="memdesc:gaf50f6b198924b15f2438ee3b17592a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy</code> <br /></td></tr>
<tr class="separator:gaf50f6b198924b15f2438ee3b17592a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeba46d1adac789ca667c5bbb81e8682"><td class="memTemplParams" colspan="2"><a id="gaeeba46d1adac789ca667c5bbb81e8682" name="gaeeba46d1adac789ca667c5bbb81e8682"></a>
template&lt;typename Rng , typename O &gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:gaeeba46d1adac789ca667c5bbb81e8682"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:gaeeba46d1adac789ca667c5bbb81e8682"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaeeba46d1adac789ca667c5bbb81e8682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aab005918621eed20b46ae6ac92de56"><td class="memTemplParams" colspan="2"><a id="ga2aab005918621eed20b46ae6ac92de56" name="ga2aab005918621eed20b46ae6ac92de56"></a>
template&lt;typename I , typename S , typename O &gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:ga2aab005918621eed20b46ae6ac92de56"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_backward_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_backward</b> (I first, S end_, O out)</td></tr>
<tr class="memdesc:ga2aab005918621eed20b46ae6ac92de56"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_backward</code> <br /></td></tr>
<tr class="separator:ga2aab005918621eed20b46ae6ac92de56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0605c89fbc214263d7db243529aeaf1"><td class="memTemplParams" colspan="2"><a id="gaa0605c89fbc214263d7db243529aeaf1" name="gaa0605c89fbc214263d7db243529aeaf1"></a>
template&lt;typename Rng , typename O &gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:gaa0605c89fbc214263d7db243529aeaf1"><td class="memTemplItemLeft" align="right" valign="top">copy_backward_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt; constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_backward</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:gaa0605c89fbc214263d7db243529aeaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaa0605c89fbc214263d7db243529aeaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bf549e35a88461196d0184014435d84"><td class="memTemplParams" colspan="2"><a id="ga9bf549e35a88461196d0184014435d84" name="ga9bf549e35a88461196d0184014435d84"></a>
template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:ga9bf549e35a88461196d0184014435d84"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_if_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_if</b> (I first, S last, O out, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga9bf549e35a88461196d0184014435d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_if</code> <br /></td></tr>
<tr class="separator:ga9bf549e35a88461196d0184014435d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dec2f6469e25cd685555f8dcd6fd0a0"><td class="memTemplParams" colspan="2"><a id="ga8dec2f6469e25cd685555f8dcd6fd0a0" name="ga8dec2f6469e25cd685555f8dcd6fd0a0"></a>
template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:ga8dec2f6469e25cd685555f8dcd6fd0a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_if</b> (Rng &amp;&amp;rng, O out, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga8dec2f6469e25cd685555f8dcd6fd0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga8dec2f6469e25cd685555f8dcd6fd0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ea36cd6df193d6663849d3d92aa7c1"><td class="memTemplParams" colspan="2"><a id="gaf0ea36cd6df193d6663849d3d92aa7c1" name="gaf0ea36cd6df193d6663849d3d92aa7c1"></a>
template&lt;typename I , typename O , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:gaf0ea36cd6df193d6663849d3d92aa7c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr copy_n_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::copy_n</b> (I first, iter_difference_t&lt; I &gt; n, O out)</td></tr>
<tr class="memdesc:gaf0ea36cd6df193d6663849d3d92aa7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>copy_n</code> <br /></td></tr>
<tr class="separator:gaf0ea36cd6df193d6663849d3d92aa7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ab8b0521304d8d45a8ccbd97937d848"><td class="memTemplParams" colspan="2"><a id="ga2ab8b0521304d8d45a8ccbd97937d848" name="ga2ab8b0521304d8d45a8ccbd97937d848"></a>
template&lt;typename I , typename S , typename V , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, V const *&gt;</td></tr>
<tr class="memitem:ga2ab8b0521304d8d45a8ccbd97937d848"><td class="memTemplItemLeft" align="right" valign="top">constexpr iter_difference_t&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::count</b> (I first, S last, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga2ab8b0521304d8d45a8ccbd97937d848"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count</code> <br /></td></tr>
<tr class="separator:ga2ab8b0521304d8d45a8ccbd97937d848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4468f8a503ad786606a2d734821b793"><td class="memTemplParams" colspan="2"><a id="gaa4468f8a503ad786606a2d734821b793" name="gaa4468f8a503ad786606a2d734821b793"></a>
template&lt;typename Rng , typename V , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, V const *&gt;</td></tr>
<tr class="memitem:gaa4468f8a503ad786606a2d734821b793"><td class="memTemplItemLeft" align="right" valign="top">constexpr iter_difference_t&lt; iterator_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::count</b> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gaa4468f8a503ad786606a2d734821b793"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaa4468f8a503ad786606a2d734821b793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2857daba0c5d6dd40a65f50bdbf829d1"><td class="memTemplParams" colspan="2"><a id="ga2857daba0c5d6dd40a65f50bdbf829d1" name="ga2857daba0c5d6dd40a65f50bdbf829d1"></a>
template&lt;typename I , typename S , typename R , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;R, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga2857daba0c5d6dd40a65f50bdbf829d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr iter_difference_t&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::count_if</b> (I first, S last, R pred, P proj=P{})</td></tr>
<tr class="memdesc:ga2857daba0c5d6dd40a65f50bdbf829d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>count_if</code> <br /></td></tr>
<tr class="separator:ga2857daba0c5d6dd40a65f50bdbf829d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7029d66f7868bf69802d01469361afbb"><td class="memTemplParams" colspan="2"><a id="ga7029d66f7868bf69802d01469361afbb" name="ga7029d66f7868bf69802d01469361afbb"></a>
template&lt;typename Rng , typename R , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga7029d66f7868bf69802d01469361afbb"><td class="memTemplItemLeft" align="right" valign="top">constexpr iter_difference_t&lt; iterator_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::count_if</b> (Rng &amp;&amp;rng, R pred, P proj=P{})</td></tr>
<tr class="memdesc:ga7029d66f7868bf69802d01469361afbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga7029d66f7868bf69802d01469361afbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375440003ecb8efa99d1b3bd5ff6c6f3"><td class="memTemplParams" colspan="2"><a id="ga375440003ecb8efa99d1b3bd5ff6c6f3" name="ga375440003ecb8efa99d1b3bd5ff6c6f3"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires ((forward_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt;) || (input_iterator&lt;I0&gt; &amp;&amp; sized_sentinel_for&lt;S0, I0&gt;)) &amp;&amp; ((forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt;) || (input_iterator&lt;I1&gt; &amp;&amp; sized_sentinel_for&lt;S1, I1&gt;)) &amp;&amp; indirectly_comparable&lt;I0, I1, C, P0, P1&gt;</td></tr>
<tr class="memitem:ga375440003ecb8efa99d1b3bd5ff6c6f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::ends_with</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga375440003ecb8efa99d1b3bd5ff6c6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>ends_with</code> <br /></td></tr>
<tr class="separator:ga375440003ecb8efa99d1b3bd5ff6c6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b4132c9646b443152edf8952ecfcba"><td class="memTemplParams" colspan="2"><a id="gad2b4132c9646b443152edf8952ecfcba" name="gad2b4132c9646b443152edf8952ecfcba"></a>
template&lt;typename Rng0 , typename <a class="el" href="classRng1.html">Rng1</a> , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires (forward_range&lt;Rng0&gt; || (input_range&lt;Rng0&gt; &amp;&amp; sized_range&lt;Rng0&gt;)) &amp;&amp; (forward_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; || (input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; sized_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;)) &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, C, P0, P1&gt;</td></tr>
<tr class="memitem:gad2b4132c9646b443152edf8952ecfcba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::ends_with</b> (Rng0 &amp;&amp;rng0, <a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gad2b4132c9646b443152edf8952ecfcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gad2b4132c9646b443152edf8952ecfcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02116ac1a7f39cc324dd959e9c1d1de"><td class="memTemplParams" colspan="2"><a id="gad02116ac1a7f39cc324dd959e9c1d1de" name="gad02116ac1a7f39cc324dd959e9c1d1de"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; indirectly_comparable&lt;I0, I1, C, P0, P1&gt;</td></tr>
<tr class="memitem:gad02116ac1a7f39cc324dd959e9c1d1de"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::equal</b> (I0 begin0, S0 end0, I1 begin1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gad02116ac1a7f39cc324dd959e9c1d1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code> <br /></td></tr>
<tr class="separator:gad02116ac1a7f39cc324dd959e9c1d1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935337eff636ae8cce87928e35078486"><td class="memTemplParams" colspan="2"><a id="ga935337eff636ae8cce87928e35078486" name="ga935337eff636ae8cce87928e35078486"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; indirectly_comparable&lt;I0, I1, C, P0, P1&gt;</td></tr>
<tr class="memitem:ga935337eff636ae8cce87928e35078486"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::equal</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga935337eff636ae8cce87928e35078486"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga935337eff636ae8cce87928e35078486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b8c41a9537c002796168f4091b179f"><td class="memTemplParams" colspan="2"><a id="gaa4b8c41a9537c002796168f4091b179f" name="gaa4b8c41a9537c002796168f4091b179f"></a>
template&lt;typename Rng0 , typename I1Ref , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_range&lt;Rng0&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I1Ref&gt;&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, uncvref_t&lt;I1Ref&gt;, C, P0, P1&gt;</td></tr>
<tr class="memitem:gaa4b8c41a9537c002796168f4091b179f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::equal</b> (Rng0 &amp;&amp;rng0, I1Ref &amp;&amp;begin1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gaa4b8c41a9537c002796168f4091b179f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaa4b8c41a9537c002796168f4091b179f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739619ab6adad68e745f6c3f059a3e9d"><td class="memTemplParams" colspan="2"><a id="ga739619ab6adad68e745f6c3f059a3e9d" name="ga739619ab6adad68e745f6c3f059a3e9d"></a>
template&lt;typename Rng0 , typename <a class="el" href="classRng1.html">Rng1</a> , typename C  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, C, P0, P1&gt;</td></tr>
<tr class="memitem:ga739619ab6adad68e745f6c3f059a3e9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::equal</b> (Rng0 &amp;&amp;rng0, <a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga739619ab6adad68e745f6c3f059a3e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga739619ab6adad68e745f6c3f059a3e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca897a41e3f33155e17c599efe9f880e"><td class="memTemplParams" colspan="2"><a id="gaca897a41e3f33155e17c599efe9f880e" name="gaca897a41e3f33155e17c599efe9f880e"></a>
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gaca897a41e3f33155e17c599efe9f880e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::equal_range</b> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaca897a41e3f33155e17c599efe9f880e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal_range</code> <br /></td></tr>
<tr class="separator:gaca897a41e3f33155e17c599efe9f880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df385c36907cc86a72e3bd349520805"><td class="memTemplParams" colspan="2"><a id="ga8df385c36907cc86a72e3bd349520805" name="ga8df385c36907cc86a72e3bd349520805"></a>
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga8df385c36907cc86a72e3bd349520805"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_subrange_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::equal_range</b> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga8df385c36907cc86a72e3bd349520805"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga8df385c36907cc86a72e3bd349520805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6aa5ef9acc043946270aacff9065763"><td class="memTemplParams" colspan="2"><a id="gae6aa5ef9acc043946270aacff9065763" name="gae6aa5ef9acc043946270aacff9065763"></a>
template&lt;typename O , typename S , typename V &gt; <br />
requires output_iterator&lt;O, V const &amp;&gt; &amp;&amp; sentinel_for&lt;S, O&gt;</td></tr>
<tr class="memitem:gae6aa5ef9acc043946270aacff9065763"><td class="memTemplItemLeft" align="right" valign="top">constexpr O&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fill</b> (O first, S last, V const &amp;val)</td></tr>
<tr class="memdesc:gae6aa5ef9acc043946270aacff9065763"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>fill</code> <br /></td></tr>
<tr class="separator:gae6aa5ef9acc043946270aacff9065763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebc59f9639c4862ba8ba6a1d06abef7"><td class="memTemplParams" colspan="2"><a id="gadebc59f9639c4862ba8ba6a1d06abef7" name="gadebc59f9639c4862ba8ba6a1d06abef7"></a>
template&lt;typename Rng , typename V &gt; <br />
requires output_range&lt;Rng, V const &amp;&gt;</td></tr>
<tr class="memitem:gadebc59f9639c4862ba8ba6a1d06abef7"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fill</b> (Rng &amp;&amp;rng, V const &amp;val)</td></tr>
<tr class="memdesc:gadebc59f9639c4862ba8ba6a1d06abef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gadebc59f9639c4862ba8ba6a1d06abef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8096b5e80274bb648ee44b25daf07054"><td class="memTemplParams" colspan="2"><a id="ga8096b5e80274bb648ee44b25daf07054" name="ga8096b5e80274bb648ee44b25daf07054"></a>
template&lt;typename O , typename V &gt; <br />
requires output_iterator&lt;O, V const &amp;&gt;</td></tr>
<tr class="memitem:ga8096b5e80274bb648ee44b25daf07054"><td class="memTemplItemLeft" align="right" valign="top">constexpr O&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fill_n</b> (O first, iter_difference_t&lt; O &gt; n, V const &amp;val)</td></tr>
<tr class="memdesc:ga8096b5e80274bb648ee44b25daf07054"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>equal</code> <br /></td></tr>
<tr class="separator:ga8096b5e80274bb648ee44b25daf07054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72d78b194080f3a6ba27c90c218ad5b"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename V , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, V const *&gt;</td></tr>
<tr class="memitem:gaf72d78b194080f3a6ba27c90c218ad5b"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gaf72d78b194080f3a6ba27c90c218ad5b">ranges::find</a> (I first, S last, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gaf72d78b194080f3a6ba27c90c218ad5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find</code>  <a href="group__group-algorithms.html#gaf72d78b194080f3a6ba27c90c218ad5b">More...</a><br /></td></tr>
<tr class="separator:gaf72d78b194080f3a6ba27c90c218ad5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66a8b16fb2dce7f3cebda86ccb2b0f02"><td class="memTemplParams" colspan="2"><a id="ga66a8b16fb2dce7f3cebda86ccb2b0f02" name="ga66a8b16fb2dce7f3cebda86ccb2b0f02"></a>
template&lt;typename Rng , typename V , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, V const *&gt;</td></tr>
<tr class="memitem:ga66a8b16fb2dce7f3cebda86ccb2b0f02"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::find</b> (Rng &amp;&amp;rng, V const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga66a8b16fb2dce7f3cebda86ccb2b0f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga66a8b16fb2dce7f3cebda86ccb2b0f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289f53ab261fbd1c6d8139e6d36294da"><td class="memTemplParams" colspan="2"><a id="ga289f53ab261fbd1c6d8139e6d36294da" name="ga289f53ab261fbd1c6d8139e6d36294da"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename R  = equal_to, typename P  = identity&gt; <br />
requires forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;I1, P&gt;, I2&gt;</td></tr>
<tr class="memitem:ga289f53ab261fbd1c6d8139e6d36294da"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::find_end</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:ga289f53ab261fbd1c6d8139e6d36294da"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_end</code> <br /></td></tr>
<tr class="separator:ga289f53ab261fbd1c6d8139e6d36294da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae183056c1a61d179f59b00b5966a31f1"><td class="memTemplParams" colspan="2"><a id="gae183056c1a61d179f59b00b5966a31f1" name="gae183056c1a61d179f59b00b5966a31f1"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename R  = equal_to, typename P  = identity&gt; <br />
requires forward_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; forward_range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, P&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;&gt;</td></tr>
<tr class="memitem:gae183056c1a61d179f59b00b5966a31f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_subrange_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::find_end</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:gae183056c1a61d179f59b00b5966a31f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gae183056c1a61d179f59b00b5966a31f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e08622a60f55ed678a5555061a4847b"><td class="memTemplParams" colspan="2"><a id="ga4e08622a60f55ed678a5555061a4847b" name="ga4e08622a60f55ed678a5555061a4847b"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;</td></tr>
<tr class="memitem:ga4e08622a60f55ed678a5555061a4847b"><td class="memTemplItemLeft" align="right" valign="top">constexpr I0&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::find_first_of</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, R pred=R{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga4e08622a60f55ed678a5555061a4847b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>find_first_of</code> <br /></td></tr>
<tr class="separator:ga4e08622a60f55ed678a5555061a4847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac574e4d9d7470778d6ec35f5fa8f0991"><td class="memTemplParams" colspan="2"><a id="gac574e4d9d7470778d6ec35f5fa8f0991" name="gac574e4d9d7470778d6ec35f5fa8f0991"></a>
template&lt;typename Rng0 , typename <a class="el" href="classRng1.html">Rng1</a> , typename R  = equal_to, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_range&lt;Rng0&gt; &amp;&amp; forward_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; indirect_relation&lt;R, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, P1&gt;&gt;</td></tr>
<tr class="memitem:gac574e4d9d7470778d6ec35f5fa8f0991"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::find_first_of</b> (Rng0 &amp;&amp;rng0, <a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, R pred=R{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gac574e4d9d7470778d6ec35f5fa8f0991"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gac574e4d9d7470778d6ec35f5fa8f0991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe0baa92e60f782d83fb77ffac1010b4"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gafe0baa92e60f782d83fb77ffac1010b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gafe0baa92e60f782d83fb77ffac1010b4">ranges::find_if</a> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gafe0baa92e60f782d83fb77ffac1010b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find</code>  <a href="group__group-algorithms.html#gafe0baa92e60f782d83fb77ffac1010b4">More...</a><br /></td></tr>
<tr class="separator:gafe0baa92e60f782d83fb77ffac1010b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d58c672913a966235e5445f408cffca"><td class="memTemplParams" colspan="2"><a id="ga7d58c672913a966235e5445f408cffca" name="ga7d58c672913a966235e5445f408cffca"></a>
template&lt;typename Rng , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga7d58c672913a966235e5445f408cffca"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::find_if</b> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga7d58c672913a966235e5445f408cffca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga7d58c672913a966235e5445f408cffca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fdf9bbeab3ee7279c1656c1b40e4f81"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga1fdf9bbeab3ee7279c1656c1b40e4f81"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga1fdf9bbeab3ee7279c1656c1b40e4f81">ranges::find_if_not</a> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga1fdf9bbeab3ee7279c1656c1b40e4f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>find_if_not</code>  <a href="group__group-algorithms.html#ga1fdf9bbeab3ee7279c1656c1b40e4f81">More...</a><br /></td></tr>
<tr class="separator:ga1fdf9bbeab3ee7279c1656c1b40e4f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee0fc7d9c298bf926cea3ae8e3236d14"><td class="memTemplParams" colspan="2"><a id="gaee0fc7d9c298bf926cea3ae8e3236d14" name="gaee0fc7d9c298bf926cea3ae8e3236d14"></a>
template&lt;typename Rng , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gaee0fc7d9c298bf926cea3ae8e3236d14"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::find_if_not</b> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gaee0fc7d9c298bf926cea3ae8e3236d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaee0fc7d9c298bf926cea3ae8e3236d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0284e4e6e4e971cacf83d06ec5760c21"><td class="memTemplParams" colspan="2"><a id="ga0284e4e6e4e971cacf83d06ec5760c21" name="ga0284e4e6e4e971cacf83d06ec5760c21"></a>
template&lt;typename I , typename S , typename T , typename Op &gt; <br />
requires sentinel_for&lt;S, I&gt; &amp;&amp; input_iterator&lt;I&gt; &amp;&amp; indirectly_binary_left_foldable&lt;Op, T, I&gt;</td></tr>
<tr class="memitem:ga0284e4e6e4e971cacf83d06ec5760c21"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_left</b> (I first, S last, T init, Op op)</td></tr>
<tr class="separator:ga0284e4e6e4e971cacf83d06ec5760c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30860a0a2ae53719d5418aaebec59699"><td class="memTemplParams" colspan="2"><a id="ga30860a0a2ae53719d5418aaebec59699" name="ga30860a0a2ae53719d5418aaebec59699"></a>
template&lt;typename Rng , typename T , typename Op &gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirectly_binary_left_foldable&lt;Op, T, iterator_t&lt;Rng&gt;&gt;</td></tr>
<tr class="memitem:ga30860a0a2ae53719d5418aaebec59699"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_left</b> (Rng &amp;&amp;rng, T init, Op op)</td></tr>
<tr class="separator:ga30860a0a2ae53719d5418aaebec59699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f1318c3ff06646e993a6a209be84aa7"><td class="memTemplParams" colspan="2"><a id="ga3f1318c3ff06646e993a6a209be84aa7" name="ga3f1318c3ff06646e993a6a209be84aa7"></a>
template&lt;typename I , typename S , typename Op &gt; <br />
requires sentinel_for&lt;S, I&gt; &amp;&amp; input_iterator&lt;I&gt; &amp;&amp; indirectly_binary_left_foldable&lt;Op, iter_value_t&lt;I&gt;, I&gt; &amp;&amp; constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;</td></tr>
<tr class="memitem:ga3f1318c3ff06646e993a6a209be84aa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_left_first</b> (I first, S last, Op op)</td></tr>
<tr class="separator:ga3f1318c3ff06646e993a6a209be84aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf043c6e05cbcc3b45db1102f05c00cf5"><td class="memTemplParams" colspan="2"><a id="gaf043c6e05cbcc3b45db1102f05c00cf5" name="gaf043c6e05cbcc3b45db1102f05c00cf5"></a>
template&lt;typename R , typename Op &gt; <br />
requires input_range&lt;R&gt; &amp;&amp; indirectly_binary_left_foldable&lt;Op, range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; &amp;&amp; constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;</td></tr>
<tr class="memitem:gaf043c6e05cbcc3b45db1102f05c00cf5"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_left_first</b> (R &amp;&amp;rng, Op op)</td></tr>
<tr class="separator:gaf043c6e05cbcc3b45db1102f05c00cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ae8f68b829a5e1e4226cae6f658736b"><td class="memTemplParams" colspan="2"><a id="ga3ae8f68b829a5e1e4226cae6f658736b" name="ga3ae8f68b829a5e1e4226cae6f658736b"></a>
template&lt;typename I , typename S , typename T , typename Op &gt; <br />
requires sentinel_for&lt;S, I&gt; &amp;&amp; bidirectional_iterator&lt;I&gt; &amp;&amp; indirectly_binary_right_foldable&lt;Op, T, I&gt;</td></tr>
<tr class="memitem:ga3ae8f68b829a5e1e4226cae6f658736b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_right</b> (I first, S last, T init, Op op)</td></tr>
<tr class="separator:ga3ae8f68b829a5e1e4226cae6f658736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga820f02fb0da99f3515015ac7749a0822"><td class="memTemplParams" colspan="2"><a id="ga820f02fb0da99f3515015ac7749a0822" name="ga820f02fb0da99f3515015ac7749a0822"></a>
template&lt;typename Rng , typename T , typename Op &gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; indirectly_binary_right_foldable&lt;Op, T, iterator_t&lt;Rng&gt;&gt;</td></tr>
<tr class="memitem:ga820f02fb0da99f3515015ac7749a0822"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_right</b> (Rng &amp;&amp;rng, T init, Op op)</td></tr>
<tr class="separator:ga820f02fb0da99f3515015ac7749a0822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca6c0d9ca957eee1ecf6521779eafc0"><td class="memTemplParams" colspan="2"><a id="ga9ca6c0d9ca957eee1ecf6521779eafc0" name="ga9ca6c0d9ca957eee1ecf6521779eafc0"></a>
template&lt;typename I , typename S , typename Op &gt; <br />
requires sentinel_for&lt;S, I&gt; &amp;&amp; bidirectional_iterator&lt;I&gt; &amp;&amp; indirectly_binary_right_foldable&lt;Op, iter_value_t&lt;I&gt;, I&gt; &amp;&amp; constructible_from&lt;iter_value_t&lt;I&gt;, iter_reference_t&lt;I&gt;&gt;</td></tr>
<tr class="memitem:ga9ca6c0d9ca957eee1ecf6521779eafc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_right_last</b> (I first, S last, Op op)</td></tr>
<tr class="separator:ga9ca6c0d9ca957eee1ecf6521779eafc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b8086ffa4df97f25ff7477b9a0be69"><td class="memTemplParams" colspan="2"><a id="ga74b8086ffa4df97f25ff7477b9a0be69" name="ga74b8086ffa4df97f25ff7477b9a0be69"></a>
template&lt;typename R , typename Op &gt; <br />
requires bidirectional_range&lt;R&gt; &amp;&amp; indirectly_binary_right_foldable&lt;Op, range_value_t&lt;R&gt;, iterator_t&lt;R&gt;&gt; &amp;&amp; constructible_from&lt;range_value_t&lt;R&gt;, range_reference_t&lt;R&gt;&gt;</td></tr>
<tr class="memitem:ga74b8086ffa4df97f25ff7477b9a0be69"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::fold_right_last</b> (R &amp;&amp;rng, Op op)</td></tr>
<tr class="separator:ga74b8086ffa4df97f25ff7477b9a0be69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a5c8be974556ebf18c1f2b9212dadf"><td class="memTemplParams" colspan="2"><a id="ga30a5c8be974556ebf18c1f2b9212dadf" name="ga30a5c8be974556ebf18c1f2b9212dadf"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga30a5c8be974556ebf18c1f2b9212dadf"><td class="memTemplItemLeft" align="right" valign="top">constexpr for_each_result&lt; I, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each</b> (I first, S last, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga30a5c8be974556ebf18c1f2b9212dadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>for_each</code> <br /></td></tr>
<tr class="separator:ga30a5c8be974556ebf18c1f2b9212dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2551b95c39612d7239ecf832abdf4c13"><td class="memTemplParams" colspan="2"><a id="ga2551b95c39612d7239ecf832abdf4c13" name="ga2551b95c39612d7239ecf832abdf4c13"></a>
template&lt;typename Rng , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga2551b95c39612d7239ecf832abdf4c13"><td class="memTemplItemLeft" align="right" valign="top">constexpr for_each_result&lt; borrowed_iterator_t&lt; Rng &gt;, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each</b> (Rng &amp;&amp;rng, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga2551b95c39612d7239ecf832abdf4c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga2551b95c39612d7239ecf832abdf4c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f9951d331c016737ad1e5793feb861"><td class="memTemplParams" colspan="2"><a id="gad2f9951d331c016737ad1e5793feb861" name="gad2f9951d331c016737ad1e5793feb861"></a>
template&lt;typename I , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gad2f9951d331c016737ad1e5793feb861"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each_n</b> (I first, iter_difference_t&lt; I &gt; n, F fun, P proj=P{})</td></tr>
<tr class="memdesc:gad2f9951d331c016737ad1e5793feb861"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>for_each_n</code> <br /></td></tr>
<tr class="separator:gad2f9951d331c016737ad1e5793feb861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga464690c9e3361c7764fdfd226cd5820d"><td class="memTemplParams" colspan="2"><a id="ga464690c9e3361c7764fdfd226cd5820d" name="ga464690c9e3361c7764fdfd226cd5820d"></a>
template&lt;typename Rng , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirectly_unary_invocable&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga464690c9e3361c7764fdfd226cd5820d"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::for_each_n</b> (Rng &amp;&amp;rng, range_difference_t&lt; Rng &gt; n, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga464690c9e3361c7764fdfd226cd5820d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga464690c9e3361c7764fdfd226cd5820d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba76cbe251af1a1f0e31bd91af0cbdb9"><td class="memTemplParams" colspan="2"><a id="gaba76cbe251af1a1f0e31bd91af0cbdb9" name="gaba76cbe251af1a1f0e31bd91af0cbdb9"></a>
template&lt;typename O , typename S , typename F &gt; <br />
requires invocable&lt;F &amp;&gt; &amp;&amp; output_iterator&lt;O, invoke_result_t&lt;F &amp;&gt;&gt; &amp;&amp; sentinel_for&lt;S, O&gt;</td></tr>
<tr class="memitem:gaba76cbe251af1a1f0e31bd91af0cbdb9"><td class="memTemplItemLeft" align="right" valign="top">constexpr generate_result&lt; O, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate</b> (O first, S last, F fun)</td></tr>
<tr class="memdesc:gaba76cbe251af1a1f0e31bd91af0cbdb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code> <br /></td></tr>
<tr class="separator:gaba76cbe251af1a1f0e31bd91af0cbdb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b861757457f4ea5b4e74db65b2160e4"><td class="memTemplParams" colspan="2"><a id="ga1b861757457f4ea5b4e74db65b2160e4" name="ga1b861757457f4ea5b4e74db65b2160e4"></a>
template&lt;typename Rng , typename F &gt; <br />
requires invocable&lt;F &amp;&gt; &amp;&amp; output_range&lt;Rng, invoke_result_t&lt;F &amp;&gt;&gt;</td></tr>
<tr class="memitem:ga1b861757457f4ea5b4e74db65b2160e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr generate_result&lt; borrowed_iterator_t&lt; Rng &gt;, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate</b> (Rng &amp;&amp;rng, F fun)</td></tr>
<tr class="memdesc:ga1b861757457f4ea5b4e74db65b2160e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga1b861757457f4ea5b4e74db65b2160e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4108a27630f879915c3cb11eb3141b5"><td class="memTemplParams" colspan="2"><a id="gae4108a27630f879915c3cb11eb3141b5" name="gae4108a27630f879915c3cb11eb3141b5"></a>
template&lt;typename O , typename F &gt; <br />
requires invocable&lt;F &amp;&gt; &amp;&amp; output_iterator&lt;O, invoke_result_t&lt;F &amp;&gt;&gt;</td></tr>
<tr class="memitem:gae4108a27630f879915c3cb11eb3141b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr generate_n_result&lt; O, F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::generate_n</b> (O first, iter_difference_t&lt; O &gt; n, F fun)</td></tr>
<tr class="memdesc:gae4108a27630f879915c3cb11eb3141b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>generate_n</code> <br /></td></tr>
<tr class="separator:gae4108a27630f879915c3cb11eb3141b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231e9ae0403ba4a1e202cd900ab6560a"><td class="memTemplParams" colspan="2"><a id="ga231e9ae0403ba4a1e202cd900ab6560a" name="ga231e9ae0403ba4a1e202cd900ab6560a"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;</td></tr>
<tr class="memitem:ga231e9ae0403ba4a1e202cd900ab6560a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::includes</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga231e9ae0403ba4a1e202cd900ab6560a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>includes</code> <br /></td></tr>
<tr class="separator:ga231e9ae0403ba4a1e202cd900ab6560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafab372272bed94eb457a3438ae05fc99"><td class="memTemplParams" colspan="2"><a id="gafab372272bed94eb457a3438ae05fc99" name="gafab372272bed94eb457a3438ae05fc99"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; input_range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, P1&gt;, projected&lt;iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, P2&gt;&gt;</td></tr>
<tr class="memitem:gafab372272bed94eb457a3438ae05fc99"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::includes</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gafab372272bed94eb457a3438ae05fc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gafab372272bed94eb457a3438ae05fc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga471e1208de3aa1f4e793a007fe5b854e"><td class="memTemplParams" colspan="2"><a id="ga471e1208de3aa1f4e793a007fe5b854e" name="ga471e1208de3aa1f4e793a007fe5b854e"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:ga471e1208de3aa1f4e793a007fe5b854e"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::inplace_merge</b> (I first, I middle, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga471e1208de3aa1f4e793a007fe5b854e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>inplace_merge</code> <br /></td></tr>
<tr class="separator:ga471e1208de3aa1f4e793a007fe5b854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf273518c12a8d45a257ba52ccdf74a"><td class="memTemplParams" colspan="2"><a id="ga9cf273518c12a8d45a257ba52ccdf74a" name="ga9cf273518c12a8d45a257ba52ccdf74a"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:ga9cf273518c12a8d45a257ba52ccdf74a"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::inplace_merge</b> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga9cf273518c12a8d45a257ba52ccdf74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga9cf273518c12a8d45a257ba52ccdf74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39dc9674ed3d76fbc50cbb58ba76d541"><td class="memTemplParams" colspan="2"><a id="ga39dc9674ed3d76fbc50cbb58ba76d541" name="ga39dc9674ed3d76fbc50cbb58ba76d541"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga39dc9674ed3d76fbc50cbb58ba76d541"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_heap</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga39dc9674ed3d76fbc50cbb58ba76d541"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_heap</code> <br /></td></tr>
<tr class="separator:ga39dc9674ed3d76fbc50cbb58ba76d541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed62ad5a0632efde05c041f1d2e3f6e0"><td class="memTemplParams" colspan="2"><a id="gaed62ad5a0632efde05c041f1d2e3f6e0" name="gaed62ad5a0632efde05c041f1d2e3f6e0"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires random_access_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gaed62ad5a0632efde05c041f1d2e3f6e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_heap</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaed62ad5a0632efde05c041f1d2e3f6e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaed62ad5a0632efde05c041f1d2e3f6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafbe72aba341a32cb58292ad3a2f7cec"><td class="memTemplParams" colspan="2"><a id="gaafbe72aba341a32cb58292ad3a2f7cec" name="gaafbe72aba341a32cb58292ad3a2f7cec"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gaafbe72aba341a32cb58292ad3a2f7cec"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_heap_until</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaafbe72aba341a32cb58292ad3a2f7cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_heap_until</code> <br /></td></tr>
<tr class="separator:gaafbe72aba341a32cb58292ad3a2f7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf6a4e446fa5e5332005cf2e561f763"><td class="memTemplParams" colspan="2"><a id="gafaf6a4e446fa5e5332005cf2e561f763" name="gafaf6a4e446fa5e5332005cf2e561f763"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires random_access_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gafaf6a4e446fa5e5332005cf2e561f763"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_heap_until</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gafaf6a4e446fa5e5332005cf2e561f763"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gafaf6a4e446fa5e5332005cf2e561f763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad57d2afed85f762cf419eb0321bffdf"><td class="memTemplParams" colspan="2"><a id="gaad57d2afed85f762cf419eb0321bffdf" name="gaad57d2afed85f762cf419eb0321bffdf"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gaad57d2afed85f762cf419eb0321bffdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_partitioned</b> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gaad57d2afed85f762cf419eb0321bffdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_partitioned</code> <br /></td></tr>
<tr class="separator:gaad57d2afed85f762cf419eb0321bffdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771500c082f792d2927fe30f4413ba1f"><td class="memTemplParams" colspan="2"><a id="ga771500c082f792d2927fe30f4413ba1f" name="ga771500c082f792d2927fe30f4413ba1f"></a>
template&lt;typename Rng , typename C , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga771500c082f792d2927fe30f4413ba1f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_partitioned</b> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga771500c082f792d2927fe30f4413ba1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga771500c082f792d2927fe30f4413ba1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a1e313c5e8d45926c1b1b3e541bea2"><td class="memTemplParams" colspan="2"><a id="ga78a1e313c5e8d45926c1b1b3e541bea2" name="ga78a1e313c5e8d45926c1b1b3e541bea2"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga78a1e313c5e8d45926c1b1b3e541bea2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_permutation</b> (I1 begin1, S1 end1, I2 begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga78a1e313c5e8d45926c1b1b3e541bea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>is_permutation</code> <br /></td></tr>
<tr class="separator:ga78a1e313c5e8d45926c1b1b3e541bea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e54464768ae85c2039c8cf54564cf82"><td class="memTemplParams" colspan="2"><a id="ga3e54464768ae85c2039c8cf54564cf82" name="ga3e54464768ae85c2039c8cf54564cf82"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga3e54464768ae85c2039c8cf54564cf82"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_permutation</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga3e54464768ae85c2039c8cf54564cf82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3e54464768ae85c2039c8cf54564cf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7684ead8bee9cb9c563075ae1740892"><td class="memTemplParams" colspan="2"><a id="gab7684ead8bee9cb9c563075ae1740892" name="gab7684ead8bee9cb9c563075ae1740892"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires forward_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; forward_iterator&lt;uncvref_t&lt;I2Ref&gt;&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, uncvref_t&lt;I2Ref&gt;, C, P1, P2&gt;</td></tr>
<tr class="memitem:gab7684ead8bee9cb9c563075ae1740892"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_permutation</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, I2Ref &amp;&amp;begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gab7684ead8bee9cb9c563075ae1740892"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab7684ead8bee9cb9c563075ae1740892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f506bcd59dba886af57ef842a7b6def"><td class="memTemplParams" colspan="2"><a id="ga2f506bcd59dba886af57ef842a7b6def" name="ga2f506bcd59dba886af57ef842a7b6def"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires forward_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; forward_range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga2f506bcd59dba886af57ef842a7b6def"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_permutation</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga2f506bcd59dba886af57ef842a7b6def"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga2f506bcd59dba886af57ef842a7b6def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ece7fef102a0c4f612716b574fa0e3"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gae6ece7fef102a0c4f612716b574fa0e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gae6ece7fef102a0c4f612716b574fa0e3">ranges::is_sorted</a> (I first, S last, R rel=R{}, P proj=P{})</td></tr>
<tr class="memdesc:gae6ece7fef102a0c4f612716b574fa0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>is_sorted</code>  <a href="group__group-algorithms.html#gae6ece7fef102a0c4f612716b574fa0e3">More...</a><br /></td></tr>
<tr class="separator:gae6ece7fef102a0c4f612716b574fa0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd221ca1a198a89310aa42b0a3098576"><td class="memTemplParams" colspan="2"><a id="gadd221ca1a198a89310aa42b0a3098576" name="gadd221ca1a198a89310aa42b0a3098576"></a>
template&lt;typename Rng , typename R  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gadd221ca1a198a89310aa42b0a3098576"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_sorted</b> (Rng &amp;&amp;rng, R rel=R{}, P proj=P{})</td></tr>
<tr class="memdesc:gadd221ca1a198a89310aa42b0a3098576"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gadd221ca1a198a89310aa42b0a3098576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e2939393c2bf52607b1e2494d30b61"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga98e2939393c2bf52607b1e2494d30b61"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga98e2939393c2bf52607b1e2494d30b61">ranges::is_sorted_until</a> (I first, S last, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:ga98e2939393c2bf52607b1e2494d30b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>is_sorted_until</code>  <a href="group__group-algorithms.html#ga98e2939393c2bf52607b1e2494d30b61">More...</a><br /></td></tr>
<tr class="separator:ga98e2939393c2bf52607b1e2494d30b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e4f20bbb67c4add9cba3ea2bc31427"><td class="memTemplParams" colspan="2"><a id="ga44e4f20bbb67c4add9cba3ea2bc31427" name="ga44e4f20bbb67c4add9cba3ea2bc31427"></a>
template&lt;typename Rng , typename R  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga44e4f20bbb67c4add9cba3ea2bc31427"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::is_sorted_until</b> (Rng &amp;&amp;rng, R pred=R{}, P proj=P{})</td></tr>
<tr class="memdesc:ga44e4f20bbb67c4add9cba3ea2bc31427"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga44e4f20bbb67c4add9cba3ea2bc31427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8ffa149403b951eeaa3c4036f47756"><td class="memTemplParams" colspan="2"><a id="ga8a8ffa149403b951eeaa3c4036f47756" name="ga8a8ffa149403b951eeaa3c4036f47756"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename C  = less, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;</td></tr>
<tr class="memitem:ga8a8ffa149403b951eeaa3c4036f47756"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::lexicographical_compare</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga8a8ffa149403b951eeaa3c4036f47756"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>lexicographical_compare</code> <br /></td></tr>
<tr class="separator:ga8a8ffa149403b951eeaa3c4036f47756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18cd608caca8bc03df2829fde8d18f5"><td class="memTemplParams" colspan="2"><a id="gab18cd608caca8bc03df2829fde8d18f5" name="gab18cd608caca8bc03df2829fde8d18f5"></a>
template&lt;typename Rng0 , typename <a class="el" href="classRng1.html">Rng1</a> , typename C  = less, typename P0  = identity, typename P1  = identity&gt; <br />
requires input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, P1&gt;&gt;</td></tr>
<tr class="memitem:gab18cd608caca8bc03df2829fde8d18f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::lexicographical_compare</b> (Rng0 &amp;&amp;rng0, <a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gab18cd608caca8bc03df2829fde8d18f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab18cd608caca8bc03df2829fde8d18f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67759ce474b990762e2c3a44c089991"><td class="memTemplParams" colspan="2"><a id="gaf67759ce474b990762e2c3a44c089991" name="gaf67759ce474b990762e2c3a44c089991"></a>
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gaf67759ce474b990762e2c3a44c089991"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::lower_bound</b> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaf67759ce474b990762e2c3a44c089991"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>lower_bound</code> <br /></td></tr>
<tr class="separator:gaf67759ce474b990762e2c3a44c089991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2226d0e084702ef8caa0a4c29af7ff1"><td class="memTemplParams" colspan="2"><a id="gad2226d0e084702ef8caa0a4c29af7ff1" name="gad2226d0e084702ef8caa0a4c29af7ff1"></a>
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gad2226d0e084702ef8caa0a4c29af7ff1"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::lower_bound</b> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gad2226d0e084702ef8caa0a4c29af7ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gad2226d0e084702ef8caa0a4c29af7ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f49437821b5b6e106a64b7638fcafdb"><td class="memTemplParams" colspan="2"><a id="ga8f49437821b5b6e106a64b7638fcafdb" name="ga8f49437821b5b6e106a64b7638fcafdb"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:ga8f49437821b5b6e106a64b7638fcafdb"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::make_heap</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga8f49437821b5b6e106a64b7638fcafdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>make_heap</code> <br /></td></tr>
<tr class="separator:ga8f49437821b5b6e106a64b7638fcafdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17774d46bb4d7027d07661e11b048c17"><td class="memTemplParams" colspan="2"><a id="ga17774d46bb4d7027d07661e11b048c17" name="ga17774d46bb4d7027d07661e11b048c17"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:ga17774d46bb4d7027d07661e11b048c17"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::make_heap</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga17774d46bb4d7027d07661e11b048c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga17774d46bb4d7027d07661e11b048c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20ff612d5e9d7c2df13f5e31b0344956"><td class="memTemplParams" colspan="2"><a id="ga20ff612d5e9d7c2df13f5e31b0344956" name="ga20ff612d5e9d7c2df13f5e31b0344956"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt;</td></tr>
<tr class="memitem:ga20ff612d5e9d7c2df13f5e31b0344956"><td class="memTemplItemLeft" align="right" valign="top">constexpr range_value_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::max</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga20ff612d5e9d7c2df13f5e31b0344956"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga20ff612d5e9d7c2df13f5e31b0344956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea54cf8600d95250bf533aea2daa0ed"><td class="memTemplParams" colspan="2"><a id="ga2ea54cf8600d95250bf533aea2daa0ed" name="ga2ea54cf8600d95250bf533aea2daa0ed"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; <br />
requires copyable&lt;T&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</td></tr>
<tr class="memitem:ga2ea54cf8600d95250bf533aea2daa0ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::max</b> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga2ea54cf8600d95250bf533aea2daa0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga2ea54cf8600d95250bf533aea2daa0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad23c6f6702f6c86e3a83e7811209c2b3"><td class="memTemplParams" colspan="2"><a id="gad23c6f6702f6c86e3a83e7811209c2b3" name="gad23c6f6702f6c86e3a83e7811209c2b3"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; <br />
requires indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</td></tr>
<tr class="memitem:gad23c6f6702f6c86e3a83e7811209c2b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::max</b> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gad23c6f6702f6c86e3a83e7811209c2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>max</code> <br /></td></tr>
<tr class="separator:gad23c6f6702f6c86e3a83e7811209c2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga021df53f4ff746126c3b228f75b6764d"><td class="memTemplParams" colspan="2"><a id="ga021df53f4ff746126c3b228f75b6764d" name="ga021df53f4ff746126c3b228f75b6764d"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga021df53f4ff746126c3b228f75b6764d"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::max_element</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga021df53f4ff746126c3b228f75b6764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>max_element</code> <br /></td></tr>
<tr class="separator:ga021df53f4ff746126c3b228f75b6764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga897954f7c01d6ced44f8a18bfbe70150"><td class="memTemplParams" colspan="2"><a id="ga897954f7c01d6ced44f8a18bfbe70150" name="ga897954f7c01d6ced44f8a18bfbe70150"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga897954f7c01d6ced44f8a18bfbe70150"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::max_element</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga897954f7c01d6ced44f8a18bfbe70150"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga897954f7c01d6ced44f8a18bfbe70150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e49b3637524b67208e6c47686229e6"><td class="memTemplParams" colspan="2"><a id="ga96e49b3637524b67208e6c47686229e6" name="ga96e49b3637524b67208e6c47686229e6"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; <br />
requires sentinel_for&lt;S0, I0&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; mergeable&lt;I0, I1, O, C, P0, P1&gt;</td></tr>
<tr class="memitem:ga96e49b3637524b67208e6c47686229e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr merge_result&lt; I0, I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::merge</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga96e49b3637524b67208e6c47686229e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>merge</code> <br /></td></tr>
<tr class="separator:ga96e49b3637524b67208e6c47686229e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b2d14b89cbd76f6f0f88e6c074d9d0"><td class="memTemplParams" colspan="2"><a id="ga62b2d14b89cbd76f6f0f88e6c074d9d0" name="ga62b2d14b89cbd76f6f0f88e6c074d9d0"></a>
template&lt;typename Rng0 , typename <a class="el" href="classRng1.html">Rng1</a> , typename O , typename C  = less, typename P0  = identity, typename P1  = identity&gt; <br />
requires range&lt;Rng0&gt; &amp;&amp; range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; mergeable&lt;iterator_t&lt;Rng0&gt;, iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, O, C, P0, P1&gt;</td></tr>
<tr class="memitem:ga62b2d14b89cbd76f6f0f88e6c074d9d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr merge_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::merge</b> (Rng0 &amp;&amp;rng0, <a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, O out, C pred=C{}, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga62b2d14b89cbd76f6f0f88e6c074d9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga62b2d14b89cbd76f6f0f88e6c074d9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9341a401b0b86685b8ecffbf09a4f9c0"><td class="memTemplParams" colspan="2"><a id="ga9341a401b0b86685b8ecffbf09a4f9c0" name="ga9341a401b0b86685b8ecffbf09a4f9c0"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt;</td></tr>
<tr class="memitem:ga9341a401b0b86685b8ecffbf09a4f9c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr range_value_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::min</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga9341a401b0b86685b8ecffbf09a4f9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga9341a401b0b86685b8ecffbf09a4f9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845221f0caa3f90f3342898a28de4811"><td class="memTemplParams" colspan="2"><a id="ga845221f0caa3f90f3342898a28de4811" name="ga845221f0caa3f90f3342898a28de4811"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; <br />
requires copyable&lt;T&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</td></tr>
<tr class="memitem:ga845221f0caa3f90f3342898a28de4811"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::min</b> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga845221f0caa3f90f3342898a28de4811"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga845221f0caa3f90f3342898a28de4811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4e1d7b55cc4f3c682736785560f292"><td class="memTemplParams" colspan="2"><a id="ga3e4e1d7b55cc4f3c682736785560f292" name="ga3e4e1d7b55cc4f3c682736785560f292"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; <br />
requires indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</td></tr>
<tr class="memitem:ga3e4e1d7b55cc4f3c682736785560f292"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::min</b> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga3e4e1d7b55cc4f3c682736785560f292"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>min</code> <br /></td></tr>
<tr class="separator:ga3e4e1d7b55cc4f3c682736785560f292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b388e16334836ff0f36d9cfc251734a"><td class="memTemplParams" colspan="2"><a id="ga8b388e16334836ff0f36d9cfc251734a" name="ga8b388e16334836ff0f36d9cfc251734a"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga8b388e16334836ff0f36d9cfc251734a"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::min_element</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga8b388e16334836ff0f36d9cfc251734a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>min_element</code> <br /></td></tr>
<tr class="separator:ga8b388e16334836ff0f36d9cfc251734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga386daf47dfc0c4e204d40356db8df457"><td class="memTemplParams" colspan="2"><a id="ga386daf47dfc0c4e204d40356db8df457" name="ga386daf47dfc0c4e204d40356db8df457"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga386daf47dfc0c4e204d40356db8df457"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::min_element</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga386daf47dfc0c4e204d40356db8df457"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga386daf47dfc0c4e204d40356db8df457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382fd1edd60f95f4ba2eaf7d23b9864d"><td class="memTemplParams" colspan="2"><a id="ga382fd1edd60f95f4ba2eaf7d23b9864d" name="ga382fd1edd60f95f4ba2eaf7d23b9864d"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, range_value_t&lt;Rng&gt; *&gt;</td></tr>
<tr class="memitem:ga382fd1edd60f95f4ba2eaf7d23b9864d"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_result&lt; range_value_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga382fd1edd60f95f4ba2eaf7d23b9864d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga382fd1edd60f95f4ba2eaf7d23b9864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace10edd32c2fca7609b1863143659c6"><td class="memTemplParams" colspan="2"><a id="gaace10edd32c2fca7609b1863143659c6" name="gaace10edd32c2fca7609b1863143659c6"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; <br />
requires copyable&lt;T&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</td></tr>
<tr class="memitem:gaace10edd32c2fca7609b1863143659c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax</b> (std::initializer_list&lt; T &gt; const &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaace10edd32c2fca7609b1863143659c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaace10edd32c2fca7609b1863143659c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6945f19b065aa673bb10d523602acba8"><td class="memTemplParams" colspan="2"><a id="ga6945f19b065aa673bb10d523602acba8" name="ga6945f19b065aa673bb10d523602acba8"></a>
template&lt;typename T , typename C  = less, typename P  = identity&gt; <br />
requires indirect_strict_weak_order&lt;C, projected&lt;T const *, P&gt;&gt;</td></tr>
<tr class="memitem:ga6945f19b065aa673bb10d523602acba8"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_result&lt; T const &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax</b> (T const &amp;a, T const &amp;b, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga6945f19b065aa673bb10d523602acba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>minmax</code> <br /></td></tr>
<tr class="separator:ga6945f19b065aa673bb10d523602acba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad053bf0c4a68256752f1806bd7cbdd25"><td class="memTemplParams" colspan="2"><a id="gad053bf0c4a68256752f1806bd7cbdd25" name="gad053bf0c4a68256752f1806bd7cbdd25"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gad053bf0c4a68256752f1806bd7cbdd25"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_element_result&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_element</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gad053bf0c4a68256752f1806bd7cbdd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>minmax_element</code> <br /></td></tr>
<tr class="separator:gad053bf0c4a68256752f1806bd7cbdd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac12521879e79759de133b2b4d02b6759"><td class="memTemplParams" colspan="2"><a id="gac12521879e79759de133b2b4d02b6759" name="gac12521879e79759de133b2b4d02b6759"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gac12521879e79759de133b2b4d02b6759"><td class="memTemplItemLeft" align="right" valign="top">constexpr minmax_element_result&lt; borrowed_iterator_t&lt; Rng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::minmax_element</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gac12521879e79759de133b2b4d02b6759"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gac12521879e79759de133b2b4d02b6759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf62a140e62356a8d885adc36d5fd2ed"><td class="memTemplParams" colspan="2"><a id="gabf62a140e62356a8d885adc36d5fd2ed" name="gabf62a140e62356a8d885adc36d5fd2ed"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;</td></tr>
<tr class="memitem:gabf62a140e62356a8d885adc36d5fd2ed"><td class="memTemplItemLeft" align="right" valign="top">mismatch_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch</b> (I1 begin1, S1 end1, I2 begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gabf62a140e62356a8d885adc36d5fd2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>mismatch</code> <br /></td></tr>
<tr class="separator:gabf62a140e62356a8d885adc36d5fd2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b80ee8f2775b044124781132b21c76b"><td class="memTemplParams" colspan="2"><a id="ga5b80ee8f2775b044124781132b21c76b" name="ga5b80ee8f2775b044124781132b21c76b"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I1, P1&gt;, projected&lt;I2, P2&gt;&gt;</td></tr>
<tr class="memitem:ga5b80ee8f2775b044124781132b21c76b"><td class="memTemplItemLeft" align="right" valign="top">constexpr mismatch_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga5b80ee8f2775b044124781132b21c76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga5b80ee8f2775b044124781132b21c76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27cf566e2b84860c041efa5998cb6908"><td class="memTemplParams" colspan="2"><a id="ga27cf566e2b84860c041efa5998cb6908" name="ga27cf566e2b84860c041efa5998cb6908"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename I2Ref , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I2Ref&gt;&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, P1&gt;, projected&lt;uncvref_t&lt;I2Ref&gt;, P2&gt;&gt;</td></tr>
<tr class="memitem:ga27cf566e2b84860c041efa5998cb6908"><td class="memTemplItemLeft" align="right" valign="top">mismatch_result&lt; borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, uncvref_t&lt; I2Ref &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, I2Ref &amp;&amp;begin2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga27cf566e2b84860c041efa5998cb6908"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga27cf566e2b84860c041efa5998cb6908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e1e458f4fa187310bffdcec6b26134"><td class="memTemplParams" colspan="2"><a id="gab5e1e458f4fa187310bffdcec6b26134" name="gab5e1e458f4fa187310bffdcec6b26134"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; input_range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, P1&gt;, projected&lt;iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, P2&gt;&gt;</td></tr>
<tr class="memitem:gab5e1e458f4fa187310bffdcec6b26134"><td class="memTemplItemLeft" align="right" valign="top">constexpr mismatch_result&lt; borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="classRng2.html">Rng2</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::mismatch</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gab5e1e458f4fa187310bffdcec6b26134"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab5e1e458f4fa187310bffdcec6b26134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd5afd794d00465b5d9784e1d975f848"><td class="memTemplParams" colspan="2"><a id="gafd5afd794d00465b5d9784e1d975f848" name="gafd5afd794d00465b5d9784e1d975f848"></a>
template&lt;typename I , typename S , typename O &gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_movable&lt;I, O&gt;</td></tr>
<tr class="memitem:gafd5afd794d00465b5d9784e1d975f848"><td class="memTemplItemLeft" align="right" valign="top">constexpr move_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move</b> (I first, S last, O out)</td></tr>
<tr class="memdesc:gafd5afd794d00465b5d9784e1d975f848"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>move</code> <br /></td></tr>
<tr class="separator:gafd5afd794d00465b5d9784e1d975f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3075e1b920b6ce7f45cc55b986d4297e"><td class="memTemplParams" colspan="2"><a id="ga3075e1b920b6ce7f45cc55b986d4297e" name="ga3075e1b920b6ce7f45cc55b986d4297e"></a>
template&lt;typename Rng , typename O &gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_movable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:ga3075e1b920b6ce7f45cc55b986d4297e"><td class="memTemplItemLeft" align="right" valign="top">constexpr move_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:ga3075e1b920b6ce7f45cc55b986d4297e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3075e1b920b6ce7f45cc55b986d4297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e3a2fb02a93666a06328cf49e31a2e"><td class="memTemplParams" colspan="2"><a id="ga34e3a2fb02a93666a06328cf49e31a2e" name="ga34e3a2fb02a93666a06328cf49e31a2e"></a>
template&lt;typename I , typename S , typename O &gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_movable&lt;I, O&gt;</td></tr>
<tr class="memitem:ga34e3a2fb02a93666a06328cf49e31a2e"><td class="memTemplItemLeft" align="right" valign="top">constexpr move_backward_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_backward</b> (I first, S end_, O out)</td></tr>
<tr class="memdesc:ga34e3a2fb02a93666a06328cf49e31a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>move_backward</code> <br /></td></tr>
<tr class="separator:ga34e3a2fb02a93666a06328cf49e31a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a3ce8649b03ae57e8794d3e2e87b64"><td class="memTemplParams" colspan="2"><a id="ga91a3ce8649b03ae57e8794d3e2e87b64" name="ga91a3ce8649b03ae57e8794d3e2e87b64"></a>
template&lt;typename Rng , typename O &gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; bidirectional_iterator&lt;O&gt; &amp;&amp; indirectly_movable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:ga91a3ce8649b03ae57e8794d3e2e87b64"><td class="memTemplItemLeft" align="right" valign="top">constexpr move_backward_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::move_backward</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:ga91a3ce8649b03ae57e8794d3e2e87b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga91a3ce8649b03ae57e8794d3e2e87b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe88fbbc4eff4c6afdf5c0de2180769"><td class="memTemplParams" colspan="2"><a id="ga8fe88fbbc4eff4c6afdf5c0de2180769" name="ga8fe88fbbc4eff4c6afdf5c0de2180769"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:ga8fe88fbbc4eff4c6afdf5c0de2180769"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::next_permutation</b> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga8fe88fbbc4eff4c6afdf5c0de2180769"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>next_permutation</code> <br /></td></tr>
<tr class="separator:ga8fe88fbbc4eff4c6afdf5c0de2180769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5df00bb09ce44ad908e408b2ddc0151e"><td class="memTemplParams" colspan="2"><a id="ga5df00bb09ce44ad908e408b2ddc0151e" name="ga5df00bb09ce44ad908e408b2ddc0151e"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:ga5df00bb09ce44ad908e408b2ddc0151e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::next_permutation</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga5df00bb09ce44ad908e408b2ddc0151e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga5df00bb09ce44ad908e408b2ddc0151e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5356c922f0283f541d28058f252f75d"><td class="memTemplParams" colspan="2"><a id="gab5356c922f0283f541d28058f252f75d" name="gab5356c922f0283f541d28058f252f75d"></a>
template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gab5356c922f0283f541d28058f252f75d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::none_of</b> (I first, S last, F pred, P proj=P{})</td></tr>
<tr class="memdesc:gab5356c922f0283f541d28058f252f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>none_of</code> <br /></td></tr>
<tr class="separator:gab5356c922f0283f541d28058f252f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5245a2fc0601690f9059fdddc1d40e"><td class="memTemplParams" colspan="2"><a id="ga3d5245a2fc0601690f9059fdddc1d40e" name="ga3d5245a2fc0601690f9059fdddc1d40e"></a>
template&lt;typename Rng , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga3d5245a2fc0601690f9059fdddc1d40e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::none_of</b> (Rng &amp;&amp;rng, F pred, P proj=P{})</td></tr>
<tr class="memdesc:ga3d5245a2fc0601690f9059fdddc1d40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3d5245a2fc0601690f9059fdddc1d40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9b450d088190c5a571c2b563cd8b503"><td class="memTemplParams" colspan="2"><a id="gad9b450d088190c5a571c2b563cd8b503" name="gad9b450d088190c5a571c2b563cd8b503"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:gad9b450d088190c5a571c2b563cd8b503"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::nth_element</b> (I first, I nth, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gad9b450d088190c5a571c2b563cd8b503"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>nth_element</code> <br /></td></tr>
<tr class="separator:gad9b450d088190c5a571c2b563cd8b503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ee8b883eba803c8e51de2fc48adee6"><td class="memTemplParams" colspan="2"><a id="gab0ee8b883eba803c8e51de2fc48adee6" name="gab0ee8b883eba803c8e51de2fc48adee6"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:gab0ee8b883eba803c8e51de2fc48adee6"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::nth_element</b> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; nth, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gab0ee8b883eba803c8e51de2fc48adee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab0ee8b883eba803c8e51de2fc48adee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e5905bc6e7dfe8ddd7411aadbe8fac8"><td class="memTemplParams" colspan="2"><a id="ga1e5905bc6e7dfe8ddd7411aadbe8fac8" name="ga1e5905bc6e7dfe8ddd7411aadbe8fac8"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires sortable&lt;I, C, P&gt; &amp;&amp; random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</td></tr>
<tr class="memitem:ga1e5905bc6e7dfe8ddd7411aadbe8fac8"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partial_sort</b> (I first, I middle, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga1e5905bc6e7dfe8ddd7411aadbe8fac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partial_sort</code> <br /></td></tr>
<tr class="separator:ga1e5905bc6e7dfe8ddd7411aadbe8fac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf670ddb9e845e2a520922fa43dfaae7"><td class="memTemplParams" colspan="2"><a id="gadf670ddb9e845e2a520922fa43dfaae7" name="gadf670ddb9e845e2a520922fa43dfaae7"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt;</td></tr>
<tr class="memitem:gadf670ddb9e845e2a520922fa43dfaae7"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partial_sort</b> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gadf670ddb9e845e2a520922fa43dfaae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gadf670ddb9e845e2a520922fa43dfaae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7421d4c902a4fae9fd11b2f095170199"><td class="memTemplParams" colspan="2"><a id="ga7421d4c902a4fae9fd11b2f095170199" name="ga7421d4c902a4fae9fd11b2f095170199"></a>
template&lt;typename I , typename SI , typename O , typename SO , typename C  = less, typename PI  = identity, typename PO  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;SI, I&gt; &amp;&amp; random_access_iterator&lt;O&gt; &amp;&amp; sentinel_for&lt;SO, O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; sortable&lt;O, C, PO&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;I, PI&gt;, projected&lt;O, PO&gt;&gt;</td></tr>
<tr class="memitem:ga7421d4c902a4fae9fd11b2f095170199"><td class="memTemplItemLeft" align="right" valign="top">constexpr O&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partial_sort_copy</b> (I first, SI last, O out_begin, SO out_end, C pred=C{}, PI in_proj=PI{}, PO out_proj=PO{})</td></tr>
<tr class="memdesc:ga7421d4c902a4fae9fd11b2f095170199"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partial_sort_copy</code> <br /></td></tr>
<tr class="separator:ga7421d4c902a4fae9fd11b2f095170199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdb2e487ed655592e17136b26cbc2f64"><td class="memTemplParams" colspan="2"><a id="gabdb2e487ed655592e17136b26cbc2f64" name="gabdb2e487ed655592e17136b26cbc2f64"></a>
template&lt;typename InRng , typename OutRng , typename C  = less, typename PI  = identity, typename PO  = identity&gt; <br />
requires input_range&lt;InRng&gt; &amp;&amp; random_access_range&lt;OutRng&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;InRng&gt;, iterator_t&lt;OutRng&gt;&gt; &amp;&amp; sortable&lt;iterator_t&lt;OutRng&gt;, C, PO&gt; &amp;&amp; indirect_strict_weak_order&lt;C, projected&lt;iterator_t&lt;InRng&gt;, PI&gt;, projected&lt;iterator_t&lt;OutRng&gt;, PO&gt;&gt;</td></tr>
<tr class="memitem:gabdb2e487ed655592e17136b26cbc2f64"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; OutRng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partial_sort_copy</b> (InRng &amp;&amp;in_rng, OutRng &amp;&amp;out_rng, C pred=C{}, PI in_proj=PI{}, PO out_proj=PO{})</td></tr>
<tr class="memdesc:gabdb2e487ed655592e17136b26cbc2f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gabdb2e487ed655592e17136b26cbc2f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c281ce7a70bb6063fb73fb0b6453f8d"><td class="memTemplParams" colspan="2"><a id="ga9c281ce7a70bb6063fb73fb0b6453f8d" name="ga9c281ce7a70bb6063fb73fb0b6453f8d"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; <br />
requires permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga9c281ce7a70bb6063fb73fb0b6453f8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition</b> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga9c281ce7a70bb6063fb73fb0b6453f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition</code> <br /></td></tr>
<tr class="separator:ga9c281ce7a70bb6063fb73fb0b6453f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51821b8e37a34a087f0fda3e44d756fc"><td class="memTemplParams" colspan="2"><a id="ga51821b8e37a34a087f0fda3e44d756fc" name="ga51821b8e37a34a087f0fda3e44d756fc"></a>
template&lt;typename Rng , typename C , typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga51821b8e37a34a087f0fda3e44d756fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition</b> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga51821b8e37a34a087f0fda3e44d756fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga51821b8e37a34a087f0fda3e44d756fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8818eeda03738969ead1a938be36e927"><td class="memTemplParams" colspan="2"><a id="ga8818eeda03738969ead1a938be36e927" name="ga8818eeda03738969ead1a938be36e927"></a>
template&lt;typename I , typename S , typename O0 , typename O1 , typename C , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O0&gt; &amp;&amp; weakly_incrementable&lt;O1&gt; &amp;&amp; indirectly_copyable&lt;I, O0&gt; &amp;&amp; indirectly_copyable&lt;I, O1&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga8818eeda03738969ead1a938be36e927"><td class="memTemplItemLeft" align="right" valign="top">constexpr partition_copy_result&lt; I, O0, O1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_copy</b> (I first, S last, O0 o0, O1 o1, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga8818eeda03738969ead1a938be36e927"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition_copy</code> <br /></td></tr>
<tr class="separator:ga8818eeda03738969ead1a938be36e927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8f86064adcb09711e549c82a13da893"><td class="memTemplParams" colspan="2"><a id="gab8f86064adcb09711e549c82a13da893" name="gab8f86064adcb09711e549c82a13da893"></a>
template&lt;typename Rng , typename O0 , typename O1 , typename C , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O0&gt; &amp;&amp; weakly_incrementable&lt;O1&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O0&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O1&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gab8f86064adcb09711e549c82a13da893"><td class="memTemplItemLeft" align="right" valign="top">constexpr partition_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O0, O1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_copy</b> (Rng &amp;&amp;rng, O0 o0, O1 o1, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gab8f86064adcb09711e549c82a13da893"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gab8f86064adcb09711e549c82a13da893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd11423aea8fde8c1c7ac544a92d0a8"><td class="memTemplParams" colspan="2"><a id="gadbd11423aea8fde8c1c7ac544a92d0a8" name="gadbd11423aea8fde8c1c7ac544a92d0a8"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gadbd11423aea8fde8c1c7ac544a92d0a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_point</b> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gadbd11423aea8fde8c1c7ac544a92d0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>partition_point</code> <br /></td></tr>
<tr class="separator:gadbd11423aea8fde8c1c7ac544a92d0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac005f69707b065f01740de79a00afd16"><td class="memTemplParams" colspan="2"><a id="gac005f69707b065f01740de79a00afd16" name="gac005f69707b065f01740de79a00afd16"></a>
template&lt;typename Rng , typename C , typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gac005f69707b065f01740de79a00afd16"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::partition_point</b> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gac005f69707b065f01740de79a00afd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gac005f69707b065f01740de79a00afd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df061690b9d700ef786b21c868f296b"><td class="memTemplParams" colspan="2"><a id="ga6df061690b9d700ef786b21c868f296b" name="ga6df061690b9d700ef786b21c868f296b"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:ga6df061690b9d700ef786b21c868f296b"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::pop_heap</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga6df061690b9d700ef786b21c868f296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>pop_heap</code> <br /></td></tr>
<tr class="separator:ga6df061690b9d700ef786b21c868f296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922bae7ae5634bfec4d697cd687b69a5"><td class="memTemplParams" colspan="2"><a id="ga922bae7ae5634bfec4d697cd687b69a5" name="ga922bae7ae5634bfec4d697cd687b69a5"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:ga922bae7ae5634bfec4d697cd687b69a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::pop_heap</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga922bae7ae5634bfec4d697cd687b69a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga922bae7ae5634bfec4d697cd687b69a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e46bae67c88ccae773aa1673d47833"><td class="memTemplParams" colspan="2"><a id="ga72e46bae67c88ccae773aa1673d47833" name="ga72e46bae67c88ccae773aa1673d47833"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:ga72e46bae67c88ccae773aa1673d47833"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::prev_permutation</b> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga72e46bae67c88ccae773aa1673d47833"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>prev_permutation</code> <br /></td></tr>
<tr class="separator:ga72e46bae67c88ccae773aa1673d47833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8702ce0c79ea7d93439643a70f0bdb"><td class="memTemplParams" colspan="2"><a id="gafc8702ce0c79ea7d93439643a70f0bdb" name="gafc8702ce0c79ea7d93439643a70f0bdb"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:gafc8702ce0c79ea7d93439643a70f0bdb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::prev_permutation</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gafc8702ce0c79ea7d93439643a70f0bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gafc8702ce0c79ea7d93439643a70f0bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd457f1c18e3a03bd3ce1cfa91e7d0cd"><td class="memTemplParams" colspan="2"><a id="gadd457f1c18e3a03bd3ce1cfa91e7d0cd" name="gadd457f1c18e3a03bd3ce1cfa91e7d0cd"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:gadd457f1c18e3a03bd3ce1cfa91e7d0cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::push_heap</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gadd457f1c18e3a03bd3ce1cfa91e7d0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>push_heap</code> <br /></td></tr>
<tr class="separator:gadd457f1c18e3a03bd3ce1cfa91e7d0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4dfd060fba8e9da7015f85929e8030"><td class="memTemplParams" colspan="2"><a id="gaca4dfd060fba8e9da7015f85929e8030" name="gaca4dfd060fba8e9da7015f85929e8030"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires random_access_range&lt;Rng&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:gaca4dfd060fba8e9da7015f85929e8030"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::push_heap</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaca4dfd060fba8e9da7015f85929e8030"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaca4dfd060fba8e9da7015f85929e8030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae73a00a46ffcc1e091a5902de6339377"><td class="memTemplParams" colspan="2"><a id="gae73a00a46ffcc1e091a5902de6339377" name="gae73a00a46ffcc1e091a5902de6339377"></a>
template&lt;typename I , typename S , typename T , typename P  = identity&gt; <br />
requires permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T const *&gt;</td></tr>
<tr class="memitem:gae73a00a46ffcc1e091a5902de6339377"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove</b> (I first, S last, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gae73a00a46ffcc1e091a5902de6339377"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove</code> <br /></td></tr>
<tr class="separator:gae73a00a46ffcc1e091a5902de6339377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada54c08a4e437d4793eb690d0d862bcd"><td class="memTemplParams" colspan="2"><a id="gada54c08a4e437d4793eb690d0d862bcd" name="gada54c08a4e437d4793eb690d0d862bcd"></a>
template&lt;typename Rng , typename T , typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T const *&gt;</td></tr>
<tr class="memitem:gada54c08a4e437d4793eb690d0d862bcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove</b> (Rng &amp;&amp;rng, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:gada54c08a4e437d4793eb690d0d862bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gada54c08a4e437d4793eb690d0d862bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c861ec9356a95e70fc4f36d4549457"><td class="memTemplParams" colspan="2"><a id="ga27c861ec9356a95e70fc4f36d4549457" name="ga27c861ec9356a95e70fc4f36d4549457"></a>
template&lt;typename I , typename S , typename O , typename T , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T const *&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:ga27c861ec9356a95e70fc4f36d4549457"><td class="memTemplItemLeft" align="right" valign="top">constexpr remove_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy</b> (I first, S last, O out, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga27c861ec9356a95e70fc4f36d4549457"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy</code> <br /></td></tr>
<tr class="separator:ga27c861ec9356a95e70fc4f36d4549457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga409872c689888338b0f1bb7a78644e4e"><td class="memTemplParams" colspan="2"><a id="ga409872c689888338b0f1bb7a78644e4e" name="ga409872c689888338b0f1bb7a78644e4e"></a>
template&lt;typename Rng , typename O , typename T , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T const *&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:ga409872c689888338b0f1bb7a78644e4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr remove_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy</b> (Rng &amp;&amp;rng, O out, T const &amp;val, P proj=P{})</td></tr>
<tr class="memdesc:ga409872c689888338b0f1bb7a78644e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga409872c689888338b0f1bb7a78644e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4aee11f624e2db2a209e9a27c1aea09"><td class="memTemplParams" colspan="2"><a id="gad4aee11f624e2db2a209e9a27c1aea09" name="gad4aee11f624e2db2a209e9a27c1aea09"></a>
template&lt;typename I , typename S , typename O , typename C , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:gad4aee11f624e2db2a209e9a27c1aea09"><td class="memTemplItemLeft" align="right" valign="top">constexpr remove_copy_if_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_if</b> (I first, S last, O out, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gad4aee11f624e2db2a209e9a27c1aea09"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_copy_if</code> <br /></td></tr>
<tr class="separator:gad4aee11f624e2db2a209e9a27c1aea09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e119de52aade5c63f2a896707fa9327"><td class="memTemplParams" colspan="2"><a id="ga2e119de52aade5c63f2a896707fa9327" name="ga2e119de52aade5c63f2a896707fa9327"></a>
template&lt;typename Rng , typename O , typename C , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:ga2e119de52aade5c63f2a896707fa9327"><td class="memTemplItemLeft" align="right" valign="top">constexpr remove_copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_copy_if</b> (Rng &amp;&amp;rng, O out, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga2e119de52aade5c63f2a896707fa9327"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga2e119de52aade5c63f2a896707fa9327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9efe4e4adbdb10bd147b28164f8beb5"><td class="memTemplParams" colspan="2"><a id="gaa9efe4e4adbdb10bd147b28164f8beb5" name="gaa9efe4e4adbdb10bd147b28164f8beb5"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; <br />
requires permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gaa9efe4e4adbdb10bd147b28164f8beb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_if</b> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gaa9efe4e4adbdb10bd147b28164f8beb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>remove_if</code> <br /></td></tr>
<tr class="separator:gaa9efe4e4adbdb10bd147b28164f8beb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132433e716c070f59321a0c71a21652f"><td class="memTemplParams" colspan="2"><a id="ga132433e716c070f59321a0c71a21652f" name="ga132433e716c070f59321a0c71a21652f"></a>
template&lt;typename Rng , typename C , typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga132433e716c070f59321a0c71a21652f"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::remove_if</b> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:ga132433e716c070f59321a0c71a21652f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga132433e716c070f59321a0c71a21652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f64a4482ce22d35e336f1e464b7dc97"><td class="memTemplParams" colspan="2"><a id="ga4f64a4482ce22d35e336f1e464b7dc97" name="ga4f64a4482ce22d35e336f1e464b7dc97"></a>
template&lt;typename I , typename S , typename T1 , typename T2 , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirectly_writable&lt;I, T2 const &amp;&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T1 const *&gt;</td></tr>
<tr class="memitem:ga4f64a4482ce22d35e336f1e464b7dc97"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace</b> (I first, S last, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:ga4f64a4482ce22d35e336f1e464b7dc97"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace</code> <br /></td></tr>
<tr class="separator:ga4f64a4482ce22d35e336f1e464b7dc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561e8311fa9b0d4ec7a315ef3bd7affe"><td class="memTemplParams" colspan="2"><a id="ga561e8311fa9b0d4ec7a315ef3bd7affe" name="ga561e8311fa9b0d4ec7a315ef3bd7affe"></a>
template&lt;typename Rng , typename T1 , typename T2 , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirectly_writable&lt;iterator_t&lt;Rng&gt;, T2 const &amp;&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T1 const *&gt;</td></tr>
<tr class="memitem:ga561e8311fa9b0d4ec7a315ef3bd7affe"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace</b> (Rng &amp;&amp;rng, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:ga561e8311fa9b0d4ec7a315ef3bd7affe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga561e8311fa9b0d4ec7a315ef3bd7affe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d338ddf7e39de1b9996d3b540c0ac4"><td class="memTemplParams" colspan="2"><a id="gab3d338ddf7e39de1b9996d3b540c0ac4" name="gab3d338ddf7e39de1b9996d3b540c0ac4"></a>
template&lt;typename I , typename S , typename O , typename T1 , typename T2 , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; output_iterator&lt;O, T2 const &amp;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, T1 const *&gt;</td></tr>
<tr class="memitem:gab3d338ddf7e39de1b9996d3b540c0ac4"><td class="memTemplItemLeft" align="right" valign="top">constexpr replace_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy</b> (I first, S last, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:gab3d338ddf7e39de1b9996d3b540c0ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy</code> <br /></td></tr>
<tr class="separator:gab3d338ddf7e39de1b9996d3b540c0ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6aba45e1d14f128a1cf9bede39c6967"><td class="memTemplParams" colspan="2"><a id="gaa6aba45e1d14f128a1cf9bede39c6967" name="gaa6aba45e1d14f128a1cf9bede39c6967"></a>
template&lt;typename Rng , typename O , typename T1 , typename T2 , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; output_iterator&lt;O, T2 const &amp;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;iterator_t&lt;Rng&gt;, P&gt;, T1 const *&gt;</td></tr>
<tr class="memitem:gaa6aba45e1d14f128a1cf9bede39c6967"><td class="memTemplItemLeft" align="right" valign="top">constexpr replace_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy</b> (Rng &amp;&amp;rng, O out, T1 const &amp;old_value, T2 const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:gaa6aba45e1d14f128a1cf9bede39c6967"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaa6aba45e1d14f128a1cf9bede39c6967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745344a8f009a928a71bcea3a38a6e78"><td class="memTemplParams" colspan="2"><a id="ga745344a8f009a928a71bcea3a38a6e78" name="ga745344a8f009a928a71bcea3a38a6e78"></a>
template&lt;typename I , typename S , typename O , typename C , typename T , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; output_iterator&lt;O, T const &amp;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:ga745344a8f009a928a71bcea3a38a6e78"><td class="memTemplItemLeft" align="right" valign="top">constexpr replace_copy_if_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_if</b> (I first, S last, O out, C pred, T const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:ga745344a8f009a928a71bcea3a38a6e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_copy_if</code> <br /></td></tr>
<tr class="separator:ga745344a8f009a928a71bcea3a38a6e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8870f6d3d4e19d397e4f1d81a7e7caba"><td class="memTemplParams" colspan="2"><a id="ga8870f6d3d4e19d397e4f1d81a7e7caba" name="ga8870f6d3d4e19d397e4f1d81a7e7caba"></a>
template&lt;typename Rng , typename O , typename C , typename T , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; output_iterator&lt;O, T const &amp;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:ga8870f6d3d4e19d397e4f1d81a7e7caba"><td class="memTemplItemLeft" align="right" valign="top">constexpr replace_copy_if_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_copy_if</b> (Rng &amp;&amp;rng, O out, C pred, T const &amp;new_value, P proj={})</td></tr>
<tr class="memdesc:ga8870f6d3d4e19d397e4f1d81a7e7caba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga8870f6d3d4e19d397e4f1d81a7e7caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c582bb17d443f0d2ee55159da93f8c9"><td class="memTemplParams" colspan="2"><a id="ga5c582bb17d443f0d2ee55159da93f8c9" name="ga5c582bb17d443f0d2ee55159da93f8c9"></a>
template&lt;typename I , typename S , typename C , typename T , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; indirectly_writable&lt;I, T const &amp;&gt;</td></tr>
<tr class="memitem:ga5c582bb17d443f0d2ee55159da93f8c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_if</b> (I first, S last, C pred, T const &amp;new_value, P proj=P{})</td></tr>
<tr class="memdesc:ga5c582bb17d443f0d2ee55159da93f8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>replace_if</code> <br /></td></tr>
<tr class="separator:ga5c582bb17d443f0d2ee55159da93f8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1786aac3624cef10593c9195efca6e44"><td class="memTemplParams" colspan="2"><a id="ga1786aac3624cef10593c9195efca6e44" name="ga1786aac3624cef10593c9195efca6e44"></a>
template&lt;typename Rng , typename C , typename T , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; indirectly_writable&lt;iterator_t&lt;Rng&gt;, T const &amp;&gt;</td></tr>
<tr class="memitem:ga1786aac3624cef10593c9195efca6e44"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::replace_if</b> (Rng &amp;&amp;rng, C pred, T const &amp;new_value, P proj=P{})</td></tr>
<tr class="memdesc:ga1786aac3624cef10593c9195efca6e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga1786aac3624cef10593c9195efca6e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16c093c18482e6a3903d837443214b7"><td class="memTemplParams" colspan="2"><a id="gad16c093c18482e6a3903d837443214b7" name="gad16c093c18482e6a3903d837443214b7"></a>
template&lt;typename I , typename S &gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; permutable&lt;I&gt;</td></tr>
<tr class="memitem:gad16c093c18482e6a3903d837443214b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse</b> (I first, S end_)</td></tr>
<tr class="memdesc:gad16c093c18482e6a3903d837443214b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>reverse</code> <br /></td></tr>
<tr class="separator:gad16c093c18482e6a3903d837443214b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6c41b52386370a4b8b8a662809938b"><td class="memTemplParams" colspan="2"><a id="ga1d6c41b52386370a4b8b8a662809938b" name="ga1d6c41b52386370a4b8b8a662809938b"></a>
template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; permutable&lt;I&gt;</td></tr>
<tr class="memitem:ga1d6c41b52386370a4b8b8a662809938b"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse</b> (Rng &amp;&amp;rng)</td></tr>
<tr class="memdesc:ga1d6c41b52386370a4b8b8a662809938b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga1d6c41b52386370a4b8b8a662809938b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e90baa0f98a3f5c2090f54f20023910"><td class="memTemplParams" colspan="2"><a id="ga0e90baa0f98a3f5c2090f54f20023910" name="ga0e90baa0f98a3f5c2090f54f20023910"></a>
template&lt;typename I , typename S , typename O &gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:ga0e90baa0f98a3f5c2090f54f20023910"><td class="memTemplItemLeft" align="right" valign="top">constexpr reverse_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse_copy</b> (I first, S end_, O out)</td></tr>
<tr class="memdesc:ga0e90baa0f98a3f5c2090f54f20023910"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>reverse_copy</code> <br /></td></tr>
<tr class="separator:ga0e90baa0f98a3f5c2090f54f20023910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacae9ca3f4ad0b20c1f21955e054326"><td class="memTemplParams" colspan="2"><a id="gaaacae9ca3f4ad0b20c1f21955e054326" name="gaaacae9ca3f4ad0b20c1f21955e054326"></a>
template&lt;typename Rng , typename O &gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:gaaacae9ca3f4ad0b20c1f21955e054326"><td class="memTemplItemLeft" align="right" valign="top">constexpr reverse_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::reverse_copy</b> (Rng &amp;&amp;rng, O out)</td></tr>
<tr class="memdesc:gaaacae9ca3f4ad0b20c1f21955e054326"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaaacae9ca3f4ad0b20c1f21955e054326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a7c215ad231b50b33027aefc2b7208"><td class="memTemplParams" colspan="2"><a id="gaf0a7c215ad231b50b33027aefc2b7208" name="gaf0a7c215ad231b50b33027aefc2b7208"></a>
template&lt;typename I , typename S &gt; <br />
requires permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</td></tr>
<tr class="memitem:gaf0a7c215ad231b50b33027aefc2b7208"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate</b> (I first, I middle, S last)</td></tr>
<tr class="memdesc:gaf0a7c215ad231b50b33027aefc2b7208"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>rotate</code> <br /></td></tr>
<tr class="separator:gaf0a7c215ad231b50b33027aefc2b7208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac675d71f931ca61b04c8b555fa7ba25b"><td class="memTemplParams" colspan="2"><a id="gac675d71f931ca61b04c8b555fa7ba25b" name="gac675d71f931ca61b04c8b555fa7ba25b"></a>
template&lt;typename Rng , typename I  = iterator_t&lt;Rng&gt;&gt; <br />
requires range&lt;Rng&gt; &amp;&amp; permutable&lt;I&gt;</td></tr>
<tr class="memitem:gac675d71f931ca61b04c8b555fa7ba25b"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_subrange_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate</b> (Rng &amp;&amp;rng, I middle)</td></tr>
<tr class="memdesc:gac675d71f931ca61b04c8b555fa7ba25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gac675d71f931ca61b04c8b555fa7ba25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c89003bb5b7f011b6325cf0f14fd94a"><td class="memTemplParams" colspan="2"><a id="ga2c89003bb5b7f011b6325cf0f14fd94a" name="ga2c89003bb5b7f011b6325cf0f14fd94a"></a>
template&lt;typename I , typename S , typename O , typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt;</td></tr>
<tr class="memitem:ga2c89003bb5b7f011b6325cf0f14fd94a"><td class="memTemplItemLeft" align="right" valign="top">constexpr rotate_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate_copy</b> (I first, I middle, S last, O out)</td></tr>
<tr class="memdesc:ga2c89003bb5b7f011b6325cf0f14fd94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>rotate_copy</code> <br /></td></tr>
<tr class="separator:ga2c89003bb5b7f011b6325cf0f14fd94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac7f89146b07c2ddf05a65b8d98abeb5"><td class="memTemplParams" colspan="2"><a id="gaac7f89146b07c2ddf05a65b8d98abeb5" name="gaac7f89146b07c2ddf05a65b8d98abeb5"></a>
template&lt;typename Rng , typename O , typename P  = identity&gt; <br />
requires range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt;</td></tr>
<tr class="memitem:gaac7f89146b07c2ddf05a65b8d98abeb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr rotate_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::rotate_copy</b> (Rng &amp;&amp;rng, iterator_t&lt; Rng &gt; middle, O out)</td></tr>
<tr class="memdesc:gaac7f89146b07c2ddf05a65b8d98abeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaac7f89146b07c2ddf05a65b8d98abeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16ed889552345272929d57960c4cc11"><td class="memTemplParams" colspan="2"><a id="gad16ed889552345272929d57960c4cc11" name="gad16ed889552345272929d57960c4cc11"></a>
template&lt;typename I , typename S , typename O , typename Gen  = detail::default_random_engine &amp;&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (random_access_iterator&lt;O&gt; || forward_iterator&lt;I&gt; || sized_sentinel_for&lt;S, I&gt;)</td></tr>
<tr class="memitem:gad16ed889552345272929d57960c4cc11"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample</b> (I first, S last, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:gad16ed889552345272929d57960c4cc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>sample</code> <br /></td></tr>
<tr class="separator:gad16ed889552345272929d57960c4cc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6768218151c3be2b712fa85dacc6fbad"><td class="memTemplParams" colspan="2"><a id="ga6768218151c3be2b712fa85dacc6fbad" name="ga6768218151c3be2b712fa85dacc6fbad"></a>
template&lt;typename I , typename S , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;iterator_t&lt;ORng&gt;&gt; &amp;&amp; indirectly_copyable&lt;I, iterator_t&lt;ORng&gt;&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (forward_range&lt;ORng&gt; || sized_range&lt;ORng&gt;) &amp;&amp; (random_access_iterator&lt;iterator_t&lt;ORng&gt;&gt; || forward_iterator&lt;I&gt; || sized_sentinel_for&lt;S, I&gt;)</td></tr>
<tr class="memitem:ga6768218151c3be2b712fa85dacc6fbad"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; I, borrowed_iterator_t&lt; ORng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample</b> (I first, S last, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga6768218151c3be2b712fa85dacc6fbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga6768218151c3be2b712fa85dacc6fbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561d86a1fe77b317c0ce20f15922b902"><td class="memTemplParams" colspan="2"><a id="ga561d86a1fe77b317c0ce20f15922b902" name="ga561d86a1fe77b317c0ce20f15922b902"></a>
template&lt;typename IRng , typename ORng , typename Gen  = detail::default_random_engine &amp;&gt; <br />
requires input_range&lt;IRng&gt; &amp;&amp; range&lt;ORng&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;IRng&gt;, iterator_t&lt;ORng&gt;&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (random_access_iterator&lt;iterator_t&lt;ORng&gt;&gt; || forward_range&lt;IRng&gt; || sized_range&lt;IRng&gt;) &amp;&amp; (forward_range&lt;ORng&gt; || sized_range&lt;ORng&gt;)</td></tr>
<tr class="memitem:ga561d86a1fe77b317c0ce20f15922b902"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; borrowed_iterator_t&lt; IRng &gt;, borrowed_iterator_t&lt; ORng &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample</b> (IRng &amp;&amp;rng, ORng &amp;&amp;out, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga561d86a1fe77b317c0ce20f15922b902"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga561d86a1fe77b317c0ce20f15922b902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433edb35e47723fdc85dd1cd75eafbf4"><td class="memTemplParams" colspan="2"><a id="ga433edb35e47723fdc85dd1cd75eafbf4" name="ga433edb35e47723fdc85dd1cd75eafbf4"></a>
template&lt;typename Rng , typename O , typename Gen  = detail::default_random_engine &amp;&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; (random_access_iterator&lt;O&gt; || forward_range&lt;Rng&gt; || sized_range&lt;Rng&gt;)</td></tr>
<tr class="memitem:ga433edb35e47723fdc85dd1cd75eafbf4"><td class="memTemplItemLeft" align="right" valign="top">sample_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sample</b> (Rng &amp;&amp;rng, O out, iter_difference_t&lt; O &gt; const n, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga433edb35e47723fdc85dd1cd75eafbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga433edb35e47723fdc85dd1cd75eafbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a0d861132a37692b9304340be76874a"><td class="memTemplParams" colspan="2"><a id="ga9a0d861132a37692b9304340be76874a" name="ga9a0d861132a37692b9304340be76874a"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires forward_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; forward_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga9a0d861132a37692b9304340be76874a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::search</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga9a0d861132a37692b9304340be76874a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>search</code> <br /></td></tr>
<tr class="separator:ga9a0d861132a37692b9304340be76874a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2499cd9509cb652c6db667b67d9ca687"><td class="memTemplParams" colspan="2"><a id="ga2499cd9509cb652c6db667b67d9ca687" name="ga2499cd9509cb652c6db667b67d9ca687"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename C  = equal_to, typename P1  = identity, typename P2  = identity&gt; <br />
requires forward_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; forward_range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga2499cd9509cb652c6db667b67d9ca687"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_subrange_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::search</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga2499cd9509cb652c6db667b67d9ca687"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga2499cd9509cb652c6db667b67d9ca687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9114c27540c8450fb989502da4b6b28b"><td class="memTemplParams" colspan="2"><a id="ga9114c27540c8450fb989502da4b6b28b" name="ga9114c27540c8450fb989502da4b6b28b"></a>
template&lt;typename I , typename S , typename V , typename C  = equal_to, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirectly_comparable&lt;I, V const *, C, P&gt;</td></tr>
<tr class="memitem:ga9114c27540c8450fb989502da4b6b28b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structranges_1_1subrange.html">subrange</a>&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::search_n</b> (I first, S last, iter_difference_t&lt; I &gt; cnt, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga9114c27540c8450fb989502da4b6b28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>search_n</code> <br /></td></tr>
<tr class="separator:ga9114c27540c8450fb989502da4b6b28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce62448bc3b2b5cb82a0296949a84f5"><td class="memTemplParams" colspan="2"><a id="ga6ce62448bc3b2b5cb82a0296949a84f5" name="ga6ce62448bc3b2b5cb82a0296949a84f5"></a>
template&lt;typename Rng , typename V , typename C  = equal_to, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;Rng&gt;, V const *, C, P&gt;</td></tr>
<tr class="memitem:ga6ce62448bc3b2b5cb82a0296949a84f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_subrange_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::search_n</b> (Rng &amp;&amp;rng, iter_difference_t&lt; iterator_t&lt; Rng &gt; &gt; cnt, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga6ce62448bc3b2b5cb82a0296949a84f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga6ce62448bc3b2b5cb82a0296949a84f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e17e50b3bf5323d55ab640f05e41ab"><td class="memTemplParams" colspan="2"><a id="ga77e17e50b3bf5323d55ab640f05e41ab" name="ga77e17e50b3bf5323d55ab640f05e41ab"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga77e17e50b3bf5323d55ab640f05e41ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr set_difference_result&lt; I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_difference</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga77e17e50b3bf5323d55ab640f05e41ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_difference</code> <br /></td></tr>
<tr class="separator:ga77e17e50b3bf5323d55ab640f05e41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfc53e64bedbad9f236cce83cda6563"><td class="memTemplParams" colspan="2"><a id="gabbfc53e64bedbad9f236cce83cda6563" name="gabbfc53e64bedbad9f236cce83cda6563"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; mergeable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:gabbfc53e64bedbad9f236cce83cda6563"><td class="memTemplItemLeft" align="right" valign="top">constexpr set_difference_result&lt; borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_difference</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gabbfc53e64bedbad9f236cce83cda6563"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gabbfc53e64bedbad9f236cce83cda6563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5178d2299e14f08e1db3b6c8ac333c1"><td class="memTemplParams" colspan="2"><a id="gac5178d2299e14f08e1db3b6c8ac333c1" name="gac5178d2299e14f08e1db3b6c8ac333c1"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:gac5178d2299e14f08e1db3b6c8ac333c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr O&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_intersection</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gac5178d2299e14f08e1db3b6c8ac333c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_intersection</code> <br /></td></tr>
<tr class="separator:gac5178d2299e14f08e1db3b6c8ac333c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01bdb7482ca58d7df862fdb7cc235b43"><td class="memTemplParams" colspan="2"><a id="ga01bdb7482ca58d7df862fdb7cc235b43" name="ga01bdb7482ca58d7df862fdb7cc235b43"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; mergeable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga01bdb7482ca58d7df862fdb7cc235b43"><td class="memTemplItemLeft" align="right" valign="top">constexpr O&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_intersection</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga01bdb7482ca58d7df862fdb7cc235b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga01bdb7482ca58d7df862fdb7cc235b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0516d7977225afcc2fe3139d34a2095a"><td class="memTemplParams" colspan="2"><a id="ga0516d7977225afcc2fe3139d34a2095a" name="ga0516d7977225afcc2fe3139d34a2095a"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga0516d7977225afcc2fe3139d34a2095a"><td class="memTemplItemLeft" align="right" valign="top">constexpr set_symmetric_difference_result&lt; I1, I2, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_symmetric_difference</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga0516d7977225afcc2fe3139d34a2095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_symmetric_difference</code> <br /></td></tr>
<tr class="separator:ga0516d7977225afcc2fe3139d34a2095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56b614847367f64e82f123e4ef0c45d"><td class="memTemplParams" colspan="2"><a id="gaa56b614847367f64e82f123e4ef0c45d" name="gaa56b614847367f64e82f123e4ef0c45d"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; mergeable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:gaa56b614847367f64e82f123e4ef0c45d"><td class="memTemplItemLeft" align="right" valign="top">constexpr set_symmetric_difference_result&lt; borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="classRng2.html">Rng2</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_symmetric_difference</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gaa56b614847367f64e82f123e4ef0c45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaa56b614847367f64e82f123e4ef0c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d5e3fde74edbaf61261eeb4569e1b5"><td class="memTemplParams" colspan="2"><a id="gae9d5e3fde74edbaf61261eeb4569e1b5" name="gae9d5e3fde74edbaf61261eeb4569e1b5"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires sentinel_for&lt;S1, I1&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; mergeable&lt;I1, I2, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:gae9d5e3fde74edbaf61261eeb4569e1b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr set_union_result&lt; I1, I2, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_union</b> (I1 begin1, S1 end1, I2 begin2, S2 end2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:gae9d5e3fde74edbaf61261eeb4569e1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>set_union</code> <br /></td></tr>
<tr class="separator:gae9d5e3fde74edbaf61261eeb4569e1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c62b287fe7b802a91d36fe254649412"><td class="memTemplParams" colspan="2"><a id="ga4c62b287fe7b802a91d36fe254649412" name="ga4c62b287fe7b802a91d36fe254649412"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> , typename O , typename C  = less, typename P1  = identity, typename P2  = identity&gt; <br />
requires range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; mergeable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;, O, C, P1, P2&gt;</td></tr>
<tr class="memitem:ga4c62b287fe7b802a91d36fe254649412"><td class="memTemplItemLeft" align="right" valign="top">constexpr set_union_result&lt; borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="classRng2.html">Rng2</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::set_union</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2, O out, C pred=C{}, P1 proj1=P1{}, P2 proj2=P2{})</td></tr>
<tr class="memdesc:ga4c62b287fe7b802a91d36fe254649412"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga4c62b287fe7b802a91d36fe254649412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2971e0cacd08ca733f6c286fb78824"><td class="memTemplParams" colspan="2"><a id="gabd2971e0cacd08ca733f6c286fb78824" name="gabd2971e0cacd08ca733f6c286fb78824"></a>
template&lt;typename I , typename S , typename Gen  = detail::default_random_engine &amp;&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; permutable&lt;I&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; convertible_to&lt;invoke_result_t&lt;Gen &amp;&gt;, iter_difference_t&lt;I&gt;&gt;</td></tr>
<tr class="memitem:gabd2971e0cacd08ca733f6c286fb78824"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::shuffle</b> (I const first, S const last, Gen &amp;&amp;gen=detail::get_random_engine())</td></tr>
<tr class="memdesc:gabd2971e0cacd08ca733f6c286fb78824"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>shuffle</code> <br /></td></tr>
<tr class="separator:gabd2971e0cacd08ca733f6c286fb78824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9562f96c717238f449bc100e7e7165c8"><td class="memTemplParams" colspan="2"><a id="ga9562f96c717238f449bc100e7e7165c8" name="ga9562f96c717238f449bc100e7e7165c8"></a>
template&lt;typename Rng , typename Gen  = detail::default_random_engine &amp;&gt; <br />
requires random_access_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; uniform_random_bit_generator&lt;std::remove_reference_t&lt;Gen&gt;&gt; &amp;&amp; convertible_to&lt;invoke_result_t&lt;Gen &amp;&gt;, iter_difference_t&lt;iterator_t&lt;Rng&gt;&gt;&gt;</td></tr>
<tr class="memitem:ga9562f96c717238f449bc100e7e7165c8"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::shuffle</b> (Rng &amp;&amp;rng, Gen &amp;&amp;rand=detail::get_random_engine())</td></tr>
<tr class="memdesc:ga9562f96c717238f449bc100e7e7165c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga9562f96c717238f449bc100e7e7165c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5ccbe12b9d16473f2a13239ac28309a"><td class="memTemplParams" colspan="2"><a id="gaa5ccbe12b9d16473f2a13239ac28309a" name="gaa5ccbe12b9d16473f2a13239ac28309a"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires sortable&lt;I, C, P&gt; &amp;&amp; random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</td></tr>
<tr class="memitem:gaa5ccbe12b9d16473f2a13239ac28309a"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sort</b> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gaa5ccbe12b9d16473f2a13239ac28309a"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>sort</code> <br /></td></tr>
<tr class="separator:gaa5ccbe12b9d16473f2a13239ac28309a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56845e06ac4f6c17b67baf3193542022"><td class="memTemplParams" colspan="2"><a id="ga56845e06ac4f6c17b67baf3193542022" name="ga56845e06ac4f6c17b67baf3193542022"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt;</td></tr>
<tr class="memitem:ga56845e06ac4f6c17b67baf3193542022"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sort</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga56845e06ac4f6c17b67baf3193542022"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga56845e06ac4f6c17b67baf3193542022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d3c1e2a57291d4e961da35041efe21d"><td class="memTemplParams" colspan="2"><a id="ga4d3c1e2a57291d4e961da35041efe21d" name="ga4d3c1e2a57291d4e961da35041efe21d"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; sortable&lt;I, C, P&gt;</td></tr>
<tr class="memitem:ga4d3c1e2a57291d4e961da35041efe21d"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sort_heap</b> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="separator:ga4d3c1e2a57291d4e961da35041efe21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d56ac44b428cfeed32a65de1c1edd9"><td class="memTemplParams" colspan="2"><a id="ga03d56ac44b428cfeed32a65de1c1edd9" name="ga03d56ac44b428cfeed32a65de1c1edd9"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires random_access_range&lt;Rng &amp;&gt; &amp;&amp; sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt;</td></tr>
<tr class="memitem:ga03d56ac44b428cfeed32a65de1c1edd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::sort_heap</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="separator:ga03d56ac44b428cfeed32a65de1c1edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad327a619d9e4f8e7e7ef39eef497395e"><td class="memTemplParams" colspan="2"><a id="gad327a619d9e4f8e7e7ef39eef497395e" name="gad327a619d9e4f8e7e7ef39eef497395e"></a>
template&lt;typename I , typename S , typename C , typename P  = identity&gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; permutable&lt;I&gt;</td></tr>
<tr class="memitem:gad327a619d9e4f8e7e7ef39eef497395e"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::stable_partition</b> (I first, S last, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gad327a619d9e4f8e7e7ef39eef497395e"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>stable_partition</code> <br /></td></tr>
<tr class="separator:gad327a619d9e4f8e7e7ef39eef497395e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c5d5bf9ed9f835f2d6c23a964eb80f"><td class="memTemplParams" colspan="2"><a id="gad0c5d5bf9ed9f835f2d6c23a964eb80f" name="gad0c5d5bf9ed9f835f2d6c23a964eb80f"></a>
template&lt;typename Rng , typename C , typename P  = identity&gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt;</td></tr>
<tr class="memitem:gad0c5d5bf9ed9f835f2d6c23a964eb80f"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::stable_partition</b> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gad0c5d5bf9ed9f835f2d6c23a964eb80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gad0c5d5bf9ed9f835f2d6c23a964eb80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2249b0d86bbf7f133b790e4b300e8b"><td class="memTemplParams" colspan="2"><a id="gade2249b0d86bbf7f133b790e4b300e8b" name="gade2249b0d86bbf7f133b790e4b300e8b"></a>
template&lt;typename I , typename S , typename C  = less, typename P  = identity&gt; <br />
requires sortable&lt;I, C, P&gt; &amp;&amp; random_access_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</td></tr>
<tr class="memitem:gade2249b0d86bbf7f133b790e4b300e8b"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::stable_sort</b> (I first, S end_, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gade2249b0d86bbf7f133b790e4b300e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>stable_sort</code> <br /></td></tr>
<tr class="separator:gade2249b0d86bbf7f133b790e4b300e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga766a0d60ab49dc16d84abfdf5bdc40d2"><td class="memTemplParams" colspan="2"><a id="ga766a0d60ab49dc16d84abfdf5bdc40d2" name="ga766a0d60ab49dc16d84abfdf5bdc40d2"></a>
template&lt;typename Rng , typename C  = less, typename P  = identity&gt; <br />
requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; random_access_range&lt;Rng&gt;</td></tr>
<tr class="memitem:ga766a0d60ab49dc16d84abfdf5bdc40d2"><td class="memTemplItemLeft" align="right" valign="top">borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::stable_sort</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga766a0d60ab49dc16d84abfdf5bdc40d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga766a0d60ab49dc16d84abfdf5bdc40d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8d6075c5cdfee9a874d8cad97f020b"><td class="memTemplParams" colspan="2"><a id="ga5c8d6075c5cdfee9a874d8cad97f020b" name="ga5c8d6075c5cdfee9a874d8cad97f020b"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; <br />
requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_comparable&lt;I1, I2, Comp, Proj1, Proj2&gt;</td></tr>
<tr class="memitem:ga5c8d6075c5cdfee9a874d8cad97f020b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::starts_with</b> (I1 first1, S1 last1, I2 first2, S2 last2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="memdesc:ga5c8d6075c5cdfee9a874d8cad97f020b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>starts_with</code> <br /></td></tr>
<tr class="separator:ga5c8d6075c5cdfee9a874d8cad97f020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c55c137309b8b83cf3737cc4a83a23"><td class="memTemplParams" colspan="2"><a id="ga50c55c137309b8b83cf3737cc4a83a23" name="ga50c55c137309b8b83cf3737cc4a83a23"></a>
template&lt;typename R1 , typename R2 , typename Comp  = equal_to, typename Proj1  = identity, typename Proj2  = identity&gt; <br />
requires input_range&lt;R1&gt; &amp;&amp; input_range&lt;R2&gt; &amp;&amp; indirectly_comparable&lt;iterator_t&lt;R1&gt;, iterator_t&lt;R2&gt;, Comp, Proj1, Proj2&gt;</td></tr>
<tr class="memitem:ga50c55c137309b8b83cf3737cc4a83a23"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::starts_with</b> (R1 &amp;&amp;r1, R2 &amp;&amp;r2, Comp comp={}, Proj1 proj1={}, Proj2 proj2={})</td></tr>
<tr class="memdesc:ga50c55c137309b8b83cf3737cc4a83a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga50c55c137309b8b83cf3737cc4a83a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c354658b393055bdab6b11db75370ed"><td class="memTemplParams" colspan="2"><a id="ga5c354658b393055bdab6b11db75370ed" name="ga5c354658b393055bdab6b11db75370ed"></a>
template&lt;typename I1 , typename S1 , typename I2 &gt; <br />
requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; indirectly_swappable&lt;I1, I2&gt;</td></tr>
<tr class="memitem:ga5c354658b393055bdab6b11db75370ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr swap_ranges_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges</b> (I1 begin1, S1 end1, I2 begin2)</td></tr>
<tr class="memdesc:ga5c354658b393055bdab6b11db75370ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>swap_ranges</code> <br /></td></tr>
<tr class="separator:ga5c354658b393055bdab6b11db75370ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99913d873d731026c6139aa5ecc9c6cc"><td class="memTemplParams" colspan="2"><a id="ga99913d873d731026c6139aa5ecc9c6cc" name="ga99913d873d731026c6139aa5ecc9c6cc"></a>
template&lt;typename I1 , typename S1 , typename I2 , typename S2 &gt; <br />
requires input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; input_iterator&lt;I2&gt; &amp;&amp; sentinel_for&lt;S2, I2&gt; &amp;&amp; indirectly_swappable&lt;I1, I2&gt;</td></tr>
<tr class="memitem:ga99913d873d731026c6139aa5ecc9c6cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr swap_ranges_result&lt; I1, I2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges</b> (I1 begin1, S1 end1, I2 begin2, S2 end2)</td></tr>
<tr class="memdesc:ga99913d873d731026c6139aa5ecc9c6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga99913d873d731026c6139aa5ecc9c6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e342d45186d0b2bfc28efd9982e2240"><td class="memTemplParams" colspan="2"><a id="ga0e342d45186d0b2bfc28efd9982e2240" name="ga0e342d45186d0b2bfc28efd9982e2240"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename I2_ &gt; <br />
requires input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I2_&gt;&gt; &amp;&amp; indirectly_swappable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, uncvref_t&lt;I2_&gt;&gt;</td></tr>
<tr class="memitem:ga0e342d45186d0b2bfc28efd9982e2240"><td class="memTemplItemLeft" align="right" valign="top">constexpr swap_ranges_result&lt; iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, uncvref_t&lt; I2_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, I2_ &amp;&amp;begin2)</td></tr>
<tr class="separator:ga0e342d45186d0b2bfc28efd9982e2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09e49da25067cf7aa03e97490be4aa7"><td class="memTemplParams" colspan="2"><a id="gaa09e49da25067cf7aa03e97490be4aa7" name="gaa09e49da25067cf7aa03e97490be4aa7"></a>
template&lt;typename <a class="el" href="classRng1.html">Rng1</a> , typename <a class="el" href="classRng2.html">Rng2</a> &gt; <br />
requires input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; input_range&lt;<a class="el" href="classRng2.html">Rng2</a>&gt; &amp;&amp; indirectly_swappable&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, iterator_t&lt;<a class="el" href="classRng2.html">Rng2</a>&gt;&gt;</td></tr>
<tr class="memitem:gaa09e49da25067cf7aa03e97490be4aa7"><td class="memTemplItemLeft" align="right" valign="top">constexpr swap_ranges_result&lt; borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, borrowed_iterator_t&lt; <a class="el" href="classRng2.html">Rng2</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::swap_ranges</b> (<a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, <a class="el" href="classRng2.html">Rng2</a> &amp;&amp;rng2)</td></tr>
<tr class="separator:gaa09e49da25067cf7aa03e97490be4aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33143af7e3aa19ac5fd188a343c8e09b"><td class="memTemplParams" colspan="2"><a id="ga33143af7e3aa19ac5fd188a343c8e09b" name="ga33143af7e3aa19ac5fd188a343c8e09b"></a>
template&lt;typename I , typename S , typename O , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt;O, indirect_result_t&lt;F &amp;, projected&lt;I, P&gt;&gt;&gt;</td></tr>
<tr class="memitem:ga33143af7e3aa19ac5fd188a343c8e09b"><td class="memTemplItemLeft" align="right" valign="top">constexpr unary_transform_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::transform</b> (I first, S last, O out, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga33143af7e3aa19ac5fd188a343c8e09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>transform</code> <br /></td></tr>
<tr class="separator:ga33143af7e3aa19ac5fd188a343c8e09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5fcc4a54af7fb68e9cdefd6c992180"><td class="memTemplParams" colspan="2"><a id="gaed5fcc4a54af7fb68e9cdefd6c992180" name="gaed5fcc4a54af7fb68e9cdefd6c992180"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; <br />
requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;&gt;</td></tr>
<tr class="memitem:gaed5fcc4a54af7fb68e9cdefd6c992180"><td class="memTemplItemLeft" align="right" valign="top">binary_transform_result&lt; I0, I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::transform</b> (I0 begin0, S0 end0, I1 begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gaed5fcc4a54af7fb68e9cdefd6c992180"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaed5fcc4a54af7fb68e9cdefd6c992180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049db7312d3590f149be6a0383524533"><td class="memTemplParams" colspan="2"><a id="ga049db7312d3590f149be6a0383524533" name="ga049db7312d3590f149be6a0383524533"></a>
template&lt;typename I0 , typename S0 , typename I1 , typename S1 , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; <br />
requires input_iterator&lt;I0&gt; &amp;&amp; sentinel_for&lt;S0, I0&gt; &amp;&amp; input_iterator&lt;I1&gt; &amp;&amp; sentinel_for&lt;S1, I1&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;I0, P0&gt;, projected&lt;I1, P1&gt;&gt;&gt;</td></tr>
<tr class="memitem:ga049db7312d3590f149be6a0383524533"><td class="memTemplItemLeft" align="right" valign="top">constexpr binary_transform_result&lt; I0, I1, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::transform</b> (I0 begin0, S0 end0, I1 begin1, S1 end1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga049db7312d3590f149be6a0383524533"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga049db7312d3590f149be6a0383524533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89a74ae339ed3b8fb0792f18f9313ddd"><td class="memTemplParams" colspan="2"><a id="ga89a74ae339ed3b8fb0792f18f9313ddd" name="ga89a74ae339ed3b8fb0792f18f9313ddd"></a>
template&lt;typename Rng , typename O , typename F , typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt;O, indirect_result_t&lt;F &amp;, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;&gt;</td></tr>
<tr class="memitem:ga89a74ae339ed3b8fb0792f18f9313ddd"><td class="memTemplItemLeft" align="right" valign="top">constexpr unary_transform_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::transform</b> (Rng &amp;&amp;rng, O out, F fun, P proj=P{})</td></tr>
<tr class="memdesc:ga89a74ae339ed3b8fb0792f18f9313ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga89a74ae339ed3b8fb0792f18f9313ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72d3c6427e6e6f2778b774d87013f792"><td class="memTemplParams" colspan="2"><a id="ga72d3c6427e6e6f2778b774d87013f792" name="ga72d3c6427e6e6f2778b774d87013f792"></a>
template&lt;typename Rng0 , typename I1Ref , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; <br />
requires input_range&lt;Rng0&gt; &amp;&amp; input_iterator&lt;uncvref_t&lt;I1Ref&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;uncvref_t&lt;I1Ref&gt;, P1&gt;&gt;&gt;</td></tr>
<tr class="memitem:ga72d3c6427e6e6f2778b774d87013f792"><td class="memTemplItemLeft" align="right" valign="top">binary_transform_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, uncvref_t&lt; I1Ref &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::transform</b> (Rng0 &amp;&amp;rng0, I1Ref &amp;&amp;begin1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:ga72d3c6427e6e6f2778b774d87013f792"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga72d3c6427e6e6f2778b774d87013f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf26519a719b7003e5c16f478ab900060"><td class="memTemplParams" colspan="2"><a id="gaf26519a719b7003e5c16f478ab900060" name="gaf26519a719b7003e5c16f478ab900060"></a>
template&lt;typename Rng0 , typename <a class="el" href="classRng1.html">Rng1</a> , typename O , typename F , typename P0  = identity, typename P1  = identity&gt; <br />
requires input_range&lt;Rng0&gt; &amp;&amp; input_range&lt;<a class="el" href="classRng1.html">Rng1</a>&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; copy_constructible&lt;F&gt; &amp;&amp; indirectly_writable&lt; O, indirect_result_t&lt;F &amp;, projected&lt;iterator_t&lt;Rng0&gt;, P0&gt;, projected&lt;iterator_t&lt;<a class="el" href="classRng1.html">Rng1</a>&gt;, P1&gt;&gt;&gt;</td></tr>
<tr class="memitem:gaf26519a719b7003e5c16f478ab900060"><td class="memTemplItemLeft" align="right" valign="top">constexpr binary_transform_result&lt; borrowed_iterator_t&lt; Rng0 &gt;, borrowed_iterator_t&lt; <a class="el" href="classRng1.html">Rng1</a> &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::transform</b> (Rng0 &amp;&amp;rng0, <a class="el" href="classRng1.html">Rng1</a> &amp;&amp;rng1, O out, F fun, P0 proj0=P0{}, P1 proj1=P1{})</td></tr>
<tr class="memdesc:gaf26519a719b7003e5c16f478ab900060"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gaf26519a719b7003e5c16f478ab900060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga379156c62f9e56bc3e97f091eb0db830"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; <br />
requires sortable&lt;I, C, P&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</td></tr>
<tr class="memitem:ga379156c62f9e56bc3e97f091eb0db830"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga379156c62f9e56bc3e97f091eb0db830">ranges::unique</a> (I first, S last, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga379156c62f9e56bc3e97f091eb0db830"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function <code>unique</code>  <a href="group__group-algorithms.html#ga379156c62f9e56bc3e97f091eb0db830">More...</a><br /></td></tr>
<tr class="separator:ga379156c62f9e56bc3e97f091eb0db830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814af01db23206bfdc5ebcf8b03658b4"><td class="memTemplParams" colspan="2"><a id="ga814af01db23206bfdc5ebcf8b03658b4" name="ga814af01db23206bfdc5ebcf8b03658b4"></a>
template&lt;typename Rng , typename C  = equal_to, typename P  = identity&gt; <br />
requires sortable&lt;iterator_t&lt;Rng&gt;, C, P&gt; &amp;&amp; range&lt;Rng&gt;</td></tr>
<tr class="memitem:ga814af01db23206bfdc5ebcf8b03658b4"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unique</b> (Rng &amp;&amp;rng, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga814af01db23206bfdc5ebcf8b03658b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga814af01db23206bfdc5ebcf8b03658b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf007de19488bee4f383ec78c64ce09a"><td class="memTemplParams" colspan="2">template&lt;typename I , typename S , typename O , typename C  = equal_to, typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; (forward_iterator&lt;I&gt; || forward_iterator&lt;O&gt; || indirectly_copyable_storable&lt;I, O&gt;)</td></tr>
<tr class="memitem:gacf007de19488bee4f383ec78c64ce09a"><td class="memTemplItemLeft" align="right" valign="top">constexpr unique_copy_result&lt; I, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#gacf007de19488bee4f383ec78c64ce09a">ranges::unique_copy</a> (I first, S last, O out, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gacf007de19488bee4f383ec78c64ce09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template function unique_copy  <a href="group__group-algorithms.html#gacf007de19488bee4f383ec78c64ce09a">More...</a><br /></td></tr>
<tr class="separator:gacf007de19488bee4f383ec78c64ce09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bce488b81818099d49631d0a83cba2"><td class="memTemplParams" colspan="2"><a id="gae6bce488b81818099d49631d0a83cba2" name="gae6bce488b81818099d49631d0a83cba2"></a>
template&lt;typename Rng , typename O , typename C  = equal_to, typename P  = identity&gt; <br />
requires input_range&lt;Rng&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;iterator_t&lt;Rng&gt;, O&gt; &amp;&amp; (forward_iterator&lt;iterator_t&lt;Rng&gt;&gt; || forward_iterator&lt;O&gt; || indirectly_copyable_storable&lt;iterator_t&lt;Rng&gt;, O&gt;)</td></tr>
<tr class="memitem:gae6bce488b81818099d49631d0a83cba2"><td class="memTemplItemLeft" align="right" valign="top">constexpr unique_copy_result&lt; borrowed_iterator_t&lt; Rng &gt;, O &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unique_copy</b> (Rng &amp;&amp;rng, O out, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gae6bce488b81818099d49631d0a83cba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gae6bce488b81818099d49631d0a83cba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d605007b1e7bad222775b7d74258323"><td class="memTemplParams" colspan="2">template&lt;typename I , typename C , typename P  = identity&gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; permutable&lt;I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:ga2d605007b1e7bad222775b7d74258323"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group-algorithms.html#ga2d605007b1e7bad222775b7d74258323">ranges::unstable_remove_if</a> (I first, I last, C pred, P proj={})</td></tr>
<tr class="memdesc:ga2d605007b1e7bad222775b7d74258323"><td class="mdescLeft">&#160;</td><td class="mdescRight">unstable_remove have O(1) complexity for each element remove, unlike remove O(n) [for worst case]. Each erased element overwritten (moved in) with last one. unstable_remove_if does not preserve relative element order.  <a href="group__group-algorithms.html#ga2d605007b1e7bad222775b7d74258323">More...</a><br /></td></tr>
<tr class="separator:ga2d605007b1e7bad222775b7d74258323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada089b0a8c7e13a304228a04da009223"><td class="memTemplParams" colspan="2"><a id="gada089b0a8c7e13a304228a04da009223" name="gada089b0a8c7e13a304228a04da009223"></a>
template&lt;typename Rng , typename C , typename P  = identity&gt; <br />
requires bidirectional_range&lt;Rng&gt; &amp;&amp; common_range&lt;Rng&gt; &amp;&amp; permutable&lt;iterator_t&lt;Rng&gt;&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:gada089b0a8c7e13a304228a04da009223"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::unstable_remove_if</b> (Rng &amp;&amp;rng, C pred, P proj=P{})</td></tr>
<tr class="memdesc:gada089b0a8c7e13a304228a04da009223"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:gada089b0a8c7e13a304228a04da009223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d24c12ec9bce72612fc2f8a331e34b"><td class="memTemplParams" colspan="2"><a id="gad7d24c12ec9bce72612fc2f8a331e34b" name="gad7d24c12ec9bce72612fc2f8a331e34b"></a>
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</td></tr>
<tr class="memitem:gad7d24c12ec9bce72612fc2f8a331e34b"><td class="memTemplItemLeft" align="right" valign="top">constexpr I&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::upper_bound</b> (I first, S last, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:gad7d24c12ec9bce72612fc2f8a331e34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">function template <code>upper_bound</code> <br /></td></tr>
<tr class="separator:gad7d24c12ec9bce72612fc2f8a331e34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f1e3c5bc685841d60b0fe281285754e"><td class="memTemplParams" colspan="2"><a id="ga3f1e3c5bc685841d60b0fe281285754e" name="ga3f1e3c5bc685841d60b0fe281285754e"></a>
template&lt;typename Rng , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_range&lt;Rng&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;iterator_t&lt;Rng&gt;, P&gt;&gt;</td></tr>
<tr class="memitem:ga3f1e3c5bc685841d60b0fe281285754e"><td class="memTemplItemLeft" align="right" valign="top">constexpr borrowed_iterator_t&lt; Rng &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ranges::upper_bound</b> (Rng &amp;&amp;rng, V const &amp;val, C pred=C{}, P proj=P{})</td></tr>
<tr class="memdesc:ga3f1e3c5bc685841d60b0fe281285754e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:ga3f1e3c5bc685841d60b0fe281285754e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Iterator- and range-based algorithms, like the standard algorithms. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacf0b2a91574c38d011d8b768f1ca8a01" name="gacf0b2a91574c38d011d8b768f1ca8a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf0b2a91574c38d011d8b768f1ca8a01">&#9670;&nbsp;</a></span>adjacent_find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I, P&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="adjacent__find_8hpp.html">range/v3/algorithm/adjacent_find.hpp</a>&gt;</code></p>

<p>function template <code>adjacent_find</code> </p>
<p >range-based version of the <code>adjacent_find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>BinaryPredicate</code> concept </dd></dl>

</div>
</div>
<a id="gab7060ffb2fa3f5a8d659c0dac8d92d84" name="gab7060ffb2fa3f5a8d659c0dac8d92d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7060ffb2fa3f5a8d659c0dac8d92d84">&#9670;&nbsp;</a></span>adjacent_remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename Pred , typename Proj  = identity&gt; <br />
requires permutable&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;Pred, projected&lt;I, Proj&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::adjacent_remove_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Proj&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2adjacent__remove__if_8hpp.html">range/v3/algorithm/adjacent_remove_if.hpp</a>&gt;</code></p>

<p>function <code>adjacent_remove_if</code> </p>
<p >range-based version of the <code>adjacent_remove_if</code> algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept. </dd>
<dd>
<code>Pred</code> is a model of the <code>BinaryPredicate</code> concept. </dd></dl>

</div>
</div>
<a id="ga5b75f3fb053f2570b46a82a2ddbe9ca9" name="ga5b75f3fb053f2570b46a82a2ddbe9ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b75f3fb053f2570b46a82a2ddbe9ca9">&#9670;&nbsp;</a></span>binary_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename C  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;C, V const *, projected&lt;I, P&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::binary_search </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="binary__search_8hpp.html">range/v3/algorithm/binary_search.hpp</a>&gt;</code></p>

<p>function template <code>binary_search</code> </p>
<p >range-based version of the <code>binary_search</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd></dl>

</div>
</div>
<a id="gaf72d78b194080f3a6ba27c90c218ad5b" name="gaf72d78b194080f3a6ba27c90c218ad5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf72d78b194080f3a6ba27c90c218ad5b">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename V , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;<a class="el" href="structranges_1_1equal__to.html">equal_to</a>, projected&lt;I, P&gt;, V const *&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::find </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find_8hpp.html">range/v3/algorithm/find.hpp</a>&gt;</code></p>

<p>template function <code>find</code> </p>
<p >range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;iter_common_reference_t&lt;I&gt;&gt;</code> concept </dd>
<dd>
The ResultType of <code>P</code> is equality_comparable with V </dd></dl>

</div>
</div>
<a id="gafe0baa92e60f782d83fb77ffac1010b4" name="gafe0baa92e60f782d83fb77ffac1010b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe0baa92e60f782d83fb77ffac1010b4">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::find_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if_8hpp.html">range/v3/algorithm/find_if.hpp</a>&gt;</code></p>

<p>template function <code>find</code> </p>
<p >range-based version of the <code>find</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;X&gt;</code>, where <code>X</code> is the result type of <code>invocable&lt;P, V&gt;</code> </dd></dl>

</div>
</div>
<a id="ga1fdf9bbeab3ee7279c1656c1b40e4f81" name="ga1fdf9bbeab3ee7279c1656c1b40e4f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fdf9bbeab3ee7279c1656c1b40e4f81">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename F , typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_unary_predicate&lt;F, projected&lt;I, P&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::find_if_not </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="find__if__not_8hpp.html">range/v3/algorithm/find_if_not.hpp</a>&gt;</code></p>

<p>template function <code>find_if_not</code> </p>
<p >range-based version of the <code>find_if_not</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>input_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for&lt;I&gt;</code> concept </dd>
<dd>
<code>P</code> is a model of the <code>invocable&lt;V&gt;</code> concept, where <code>V</code> is the value type of I. </dd>
<dd>
<code>F</code> models <code>predicate&lt;X&gt;</code>, where <code>X</code> is the result type of <code>invocable&lt;P, V&gt;</code> </dd></dl>

</div>
</div>
<a id="gae6ece7fef102a0c4f612716b574fa0e3" name="gae6ece7fef102a0c4f612716b574fa0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ece7fef102a0c4f612716b574fa0e3">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool ranges::is_sorted </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>rel</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted_8hpp.html">range/v3/algorithm/is_sorted.hpp</a>&gt;</code></p>

<p>template function <code>is_sorted</code> </p>
<p >range-based version of the <code>is_sorted</code> std algorithm</p>
<p >Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> and <code>I</code> model the <code>sentinel_for&lt;S, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept </dd></dl>

</div>
</div>
<a id="ga98e2939393c2bf52607b1e2494d30b61" name="ga98e2939393c2bf52607b1e2494d30b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e2939393c2bf52607b1e2494d30b61">&#9670;&nbsp;</a></span>is_sorted_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename R  = less, typename P  = identity&gt; <br />
requires forward_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>pred</em> = <code>R{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="is__sorted__until_8hpp.html">range/v3/algorithm/is_sorted_until.hpp</a>&gt;</code></p>

<p>template function <code>is_sorted_until</code> </p>
<p >range-based version of the <code>is_sorted_until</code> std algorithm</p>
<p >Works on forward_ranges</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> and <code>I</code> model the <code>sentinel_for&lt;S, I&gt;</code> concept </dd>
<dd>
<code>R</code> and <code>projected&lt;I, P&gt;</code> model the <code>indirect_strict_weak_order&lt;R, projected&lt;I, P&gt;&gt;</code> concept </dd></dl>

</div>
</div>
<a id="ga379156c62f9e56bc3e97f091eb0db830" name="ga379156c62f9e56bc3e97f091eb0db830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga379156c62f9e56bc3e97f091eb0db830">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename C  = equal_to, typename P  = identity&gt; <br />
requires sortable&lt;I, C, P&gt; &amp;&amp; sentinel_for&lt;S, I&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::unique </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unique_8hpp.html">range/v3/algorithm/unique.hpp</a>&gt;</code></p>

<p>template function <code>unique</code> </p>
<p >range-based version of the <code>unique</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>forward_range</code> concept </dd>
<dd>
<code>I</code> is a model of the <code>forward_iterator</code> concept </dd>
<dd>
<code>S</code> is a model of the <code>sentinel_for</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>relation</code> concept </dd></dl>

</div>
</div>
<a id="gacf007de19488bee4f383ec78c64ce09a" name="gacf007de19488bee4f383ec78c64ce09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf007de19488bee4f383ec78c64ce09a">&#9670;&nbsp;</a></span>unique_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename S , typename O , typename C  = equal_to, typename P  = identity&gt; <br />
requires input_iterator&lt;I&gt; &amp;&amp; sentinel_for&lt;S, I&gt; &amp;&amp; indirect_relation&lt;C, projected&lt;I, P&gt;&gt; &amp;&amp; weakly_incrementable&lt;O&gt; &amp;&amp; indirectly_copyable&lt;I, O&gt; &amp;&amp; (forward_iterator&lt;I&gt; || forward_iterator&lt;O&gt; || indirectly_copyable_storable&lt;I, O&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unique_copy_result&lt; I, O &gt; ranges::unique_copy </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em> = <code>C{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>P{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="unique__copy_8hpp.html">range/v3/algorithm/unique_copy.hpp</a>&gt;</code></p>

<p>template function unique_copy </p>
<p >range-based version of the <code>unique_copy</code> std algorithm</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>Rng</code> is a model of the <code>input_range</code> concept </dd>
<dd>
<code>O</code> is a model of the <code>weakly_incrementable</code> concept </dd>
<dd>
<code>C</code> is a model of the <code>relation</code> concept </dd></dl>

</div>
</div>
<a id="ga2d605007b1e7bad222775b7d74258323" name="ga2d605007b1e7bad222775b7d74258323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d605007b1e7bad222775b7d74258323">&#9670;&nbsp;</a></span>unstable_remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename I , typename C , typename P  = identity&gt; <br />
requires bidirectional_iterator&lt;I&gt; &amp;&amp; permutable&lt;I&gt; &amp;&amp; indirect_unary_predicate&lt;C, projected&lt;I, P&gt;&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr I ranges::unstable_remove_if </td>
          <td>(</td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>proj</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="algorithm_2unstable__remove__if_8hpp.html">range/v3/algorithm/unstable_remove_if.hpp</a>&gt;</code></p>

<p>unstable_remove have O(1) complexity for each element remove, unlike remove O(n) [for worst case]. Each erased element overwritten (moved in) with last one. unstable_remove_if does not preserve relative element order. </p>
<p >function template <code>unstable_remove_if</code> </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
